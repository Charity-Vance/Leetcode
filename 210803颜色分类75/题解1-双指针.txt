方法二：双指针
思路与算法

方法一需要进行两次遍历，那么我们是否可以仅使用一次遍历呢？我们可以额外使用一个指针，即使用两个指针分别用来交换 00 和 11。

具体地，我们用指针 p_0p 
0
​
  来交换 00，p_1p 
1
​
  来交换 11，初始值都为 00。当我们从左向右遍历整个数组时：

如果找到了 11，那么将其与 \textit{nums}[p_1]nums[p 
1
​
 ] 进行交换，并将 p_1p 
1
​
  向后移动一个位置，这与方法一是相同的；

如果找到了 00，那么将其与 \textit{nums}[p_0]nums[p 
0
​
 ] 进行交换，并将 p_0p 
0
​
  向后移动一个位置。这样做是正确的吗？我们可以注意到，因为连续的 00 之后是连续的 11，因此如果我们将 00 与 \textit{nums}[p_0]nums[p 
0
​
 ] 进行交换，那么我们可能会把一个 11 交换出去。当 p_0 < p_1p 
0
​
 <p 
1
​
  时，我们已经将一些 11 连续地放在头部，此时一定会把一个 11 交换出去，导致答案错误。因此，如果 p_0 < p_1p 
0
​
 <p 
1
​
 ，那么我们需要再将 \textit{nums}[i]nums[i] 与 \textit{nums}[p_1]nums[p 
1
​
 ] 进行交换，其中 ii 是当前遍历到的位置，在进行了第一次交换后，\textit{nums}[i]nums[i] 的值为 11，我们需要将这个 11 放到「头部」的末端。在最后，无论是否有 p_0 < p_1p 
0
​
 <p 
1
​
 ，我们需要将 p_0p 
0
​
  和 p_1p 
1
​
  均向后移动一个位置，而不是仅将 p_0p 
0
​
  向后移动一个位置。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。