C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE APPDLT645
OBJECT MODULE PLACED IN .\AppDLT645.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Keil_v5 FMSH\C51\BIN\C51.EXE ..\SourceFiles\APP\AppDLT645.c LARGE OBJECTADVA
                    -NCED OPTIMIZE(8,SPEED) BROWSE DEFINE(DDSY666) DEBUG SYMBOLS PRINT(.\AppDLT645.lst) OBJECT(.\AppDLT645.obj)

line level    source

   1          /*******************************************************************************************************
   2          **** Copyrightï¼š  (c)Copyright 2019,æµ™æ±Ÿæ­£æ³°ä»ªå™¨ä»ªè¡¨æœ‰é™è´£ä»»å…¬å¸,ç”µèƒ½è¡¨åº”ç”¨ç ”å‘     
             -                  
   3          ****                            All rights reserved.                                                 
   4          **** FileName:    AppDLT645.c                                                                          
   5          **** Brief:       645åè®®é€šä¿¡å‡½æ•°                                                                   
             -  
   6          **** Author:      peter.he@chint.com                                                                 
   7          **** Version:     V1.0                                                                               
   8          **** Date:        2016-7-14                                                                          
   9          ****                                                                                                 
  10          **** note:ä¿®æ”¹å†å²è®°å½•åˆ—è¡¨ï¼Œæ¯æ¡ä¿®æ”¹è®°å½•åº”åŒ…æ‹¬ä¿®æ”¹æ—¥æœŸã€ä¿®æ”¹è€…                  
             -                        
  11          **** 1.  Author:                                                                                     
  12          ****     Version:                                                                                    
  13          ****     Date :                                                                                      
  14          **** 2.  Author:                                                                                     
  15          ****     Version:                                                                                       
  16          ****     Date:
  17          ****                                                                                        
  18          ****  addtogroup:Library                                                             
  19          **********************************************************************************************************
             -/
  20          
  21          /*--------------------------------- æ–‡ä»¶åŠŸèƒ½è¯´æ˜ ---------------------------------------------------
             -----*/
  22          /*
  23           *  è¯¥æ–‡ä»¶æ‰€æœ‰å‡½æ•°çš„å‰ç¼€ä¸ºxxxx_
  24           *  æ–‡ä»¶ä¸»å‡½æ•°å’Œå¯¹å¤–å‡½æ•°éœ€æ”¾åœ¨æ–‡ä»¶çš„é¦–éƒ¨ï¼Œå¹¶ä¸”ä¸»å‡½æ•°éœ€è¦æ”¾åœ¨ç¬¬ä¸€ä¸ªä½ç½®;
  25           *  å‡½æ•°æ³¨é‡Šé‡‡ç”¨æ ‡å‡†æ¨¡æ¿ï¼Œå‡½æ•°å†…éƒ¨æ³¨é‡Šé‡‡ç”¨//;
  26           *  å¯¹äºæ³¨é‡Šè¾ƒå¤šçš„éƒ¨åˆ†ï¼Œå¯ä»¥å¢åŠ ä¸€ä¸ªæ³¨é‡Šç¬¦ï¼Œç„¶åè¯¦ç»†è¯´æ˜æ”¾åœ¨æ–‡ä»¶çš„å°¾éƒ¨;
  27           *--------------------------------- æ–‡ä»¶åŠŸèƒ½è¯´æ˜ ---------------------------------------------------
             -----*/
  28           
  29          /**æœ‰å½¢å‚çš„å‡½æ•°æ ¼å¼:*/
  30          /*------------------------------------------------------------------------------------------------------*/
  31          /**
  32           *  @brief    xxä»»åŠ¡å¤„ç†å‡½æ•°
  33           *
  34           *  @param    xx :
  35           *
  36           *  @return   xx
  37           *
  38           *  @note     xx
  39           *
  40           */
  41          /*------------------------------------------------------------------------------------------------------*/
  42          /**æ— å½¢å‚çš„å‡½æ•°æ ¼å¼:*/
  43          /*------------------------------------------------------------------------------------------------------*/
  44          /**
  45           *  @brief    ä¸Šç”µæ‰€æœ‰å£çº¿é…ç½®æˆåˆå§‹çŠ¶æ€ï¼Œåé¢å¯æ ¹æ®éœ€è¦å¼€å¯å’Œé…ç½®
  46           *
  47           *  @return   xx
  48           *
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 2   

  49           *  @note     xx
  50           *
  51           */
  52          /*------------------------------------------------------------------------------------------------------*/
  53           
  54           
  55          /*----------------< åŒ…å«æ–‡ä»¶ >----------------------------------*/
  56          
  57          #include "..\SourceFiles\PUB\Include.h"
  58          /*----------------< å¸¸é‡å®šä¹‰ >----------------------------------*/                                    
             - 
  59          #if ( METER_TYPE == METER_TYPE_DDSY666)
  60          const uchar8 code GT_ucaFactoryVerNo[]=
  61          { 
  62                  0xFF,0xF0,              ///* åœ°åŒº *///
  63                  0x02,                   ///* 07åè®® *///
  64                  0x00,                   ///* è“ç‰™ï¼Œæ— çº¢å¤–485 *///
  65                  0x27,0x06,              ///* ç¡¬ä»¶ç‰ˆæœ¬å· *///
  66                  0x20,0x14,              ///* è¿­ä»£å· *///
  67          };
  68          const uchar8 code GT_ucaMaterType[10] = {'D','D','S','Y','6','6','6',' ',' ',' '};      ///*ç”µè¡¨å‹å· *///
  69          #elif ( METER_TYPE == METER_TYPE_DTSY666)
              const uchar8 code GT_ucaFactoryVerNo[]=
              { 
                      0xFF,0xF0,              ///* åœ°åŒº *///
                      0x02,                   ///* 07åè®® *///
                      0x00,                   ///* è“ç‰™ï¼Œæ— çº¢å¤–485 *///
                      0x27,0x07,              ///* ç¡¬ä»¶ç‰ˆæœ¬å· *///
                      0x40,0x12,              ///* è¿­ä»£å· *///
              };
              const uchar8 code GT_ucaMaterType[10] = {'D','T','S','Y','6','6','6',' ',' ',' '};      ///*ç”µè¡¨å‹å· *///
              #else
              const uchar8 code GT_ucaFactoryVerNo[]=
              { ///å¯¼è½¨è¡¨åç»­å†…éƒ¨ç‰ˆæœ¬å·éœ€è¦å‡çº§
                      0xFF,0xF0,              ///* åœ°åŒº *///
                      0x02,                   ///* 07åè®® *///
                      0x00,                   ///* è“ç‰™ï¼Œæ— çº¢å¤–485 *///
                      0x27,0x35,              ///* ç¡¬ä»¶ç‰ˆæœ¬å· *///
                      0x40,0x11,              ///* è¿­ä»£å· *///
              };
              const uchar8 code GT_ucaMaterType[10] = {'D','D','S','Y','/','U','6','6','6',' '};      ///*ç”µè¡¨å‹å· *///
              #endif
  90          #define GT_ucaFactoryVerNo_Len  sizeof(GT_ucaFactoryVerNo)
  91          
  92          const uchar8 code GT_ucaProtocolVer[16] = {'D','L','/','T',0,'6','4','5','-','2','0','0','7','-','1','4'};
             -        ///*åè®®ç‰ˆæœ¬å· *///
  93          
  94          uchar8 code C_cBleComm_Head[] = { 0xFE,0xFE,0xFE,0xFE,0x68,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x
             -00,0x68,0x00 };       /*å’Œè“ç‰™æ¨¡å—é€šä¿¡çš„æ•°æ®å‰ç¼€*/
  95                  #define C_cBleComm_Head_Len     sizeof(C_cBleComm_Head)
  96          
  97          /*----------------< å®å®šä¹‰åŒº >----------------------------------*/
  98          static const  GStr_Comm_MAP code Comm_MAP_TAB[ ]={ 
  99                  ///æ•°æ®æ ‡è¯†       RAMåœ°å€                            æ˜¯å¦å¯å†™       E2ç´¢å¼•              E2å
             -ç§»         é•¿åº¦        æ˜¯å¦BCD    EEå­˜å‚¨æ˜¯å¦ä¸ºHEX
 100                  ///ucaDataId     ucaRamAdd                          IsWrite      ucaE2pIndex            ucaE2offset  ucaDataLen
             -     IsBCD         EEISHEX
 101                  { 0x00000000 , GStr_Energy.ucaFw_Energy         ,     _FALSE , NO_BITS             ,   NO_BITS ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* å½“å‰æ€»ç”µé‡    *///0/
 102                  { 0x00010000 , GStr_Energy.ucaFw_Energy         ,     _FALSE , NO_BITS             ,   NO_BITS ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* æ­£å‘ç”µé‡      *///1/
 103                  { 0x00020000 , GStr_Energy.ucaBk_Energy         ,     _FALSE , NO_BITS             ,   NO_BITS ,     4 , 
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 3   

             -      _TRUE  ,      _FALSE     , }    ,   //* åå‘ç”µé‡      *///2/
 104                  { 0x00900201 , GStr_Money. ucaTickMoney         ,     _FALSE , NO_BITS             ,   NO_BITS ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* é€æ”¯é‡‘é¢      *///3/
 105                  { 0x00900200 , GStr_Money. ucaRemainMoney       ,     _FALSE , NO_BITS             ,   NO_BITS ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* å‰©ä½™é‡‘é¢      *///4/
 106          //      { 0x00900200 , GStr_Money. ucaRemainMoney       ,     _FALSE , NO_BITS             ,   NO_BITS ,     4 
             -,       _TRUE  ,      _FALSE     , }  ,   //* å‰©ä½™é‡‘é¢      *///5/
 107                  { 0x03300601 , GStr_PRICE .ucaPurchaseMoneyAll  ,     _FALSE , NO_BITS             ,   NO_BITS ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* æ€»è´­ç”µé‡‘é¢      *///6/
 108                  { 0x02800020 , GStr_PRICE. ucaPrice             ,     _TRUE  , LIB_E2P_Price       ,   0       ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* ç”µä»·(ä¿®æ”¹)          *///7/
 109          //      { 0x02800020 , GStr_PRICE. ucaPrice             ,     _FALSE  , LIB_E2P_Money       ,   12      ,     4
             - ,       _TRUE  ,      _FALSE     , } ,   //* ç”µä»·          *///7/
 110                  { 0x04000401 , GStr_MeterIFO. ucaCommAddr       ,     _TRUE  , LIB_E2P_METER_INFO  ,   0       ,     6 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* é€šä¿¡åœ°å€      *///8/
 111                  { 0x04000402 , GStr_MeterIFO. ucaMeterID        ,     _TRUE  , LIB_E2P_METER_INFO  ,   6       ,     6 , 
             -      _TRUE  ,      _FALSE     , }    ,   //* è¡¨å·          *///9/
 112                  { 0x0400040E , GStr_MeterIFO. ucaUserID         ,     _TRUE  , LIB_E2P_METER_INFO  ,   12      ,     6 , 
             -      _TRUE  ,      _FALSE     , }    ,   ///* å®¢æˆ·ç¼–å·      *//10/       
 113          //      { 0x04000703 , &GStr_MeterIFO. ucBpsVal         ,     _TRUE  , LIB_E2P_METER_INFO  ,   18      ,     1 
             -,       _FALSE ,      _TRUE      , }  ,   ///* æ³¢ç‰¹ç‡ç‰¹å¾å­—  *//11/     
 114                  { 0x03300100 , &GStr_EventRecordNum.ucEventTimes[0][0] ,   _FALSE , NO_BITS        ,   NO_BITS ,     4 , 
             -      _FALSE ,      _FALSE     , }    ,   ///*æ¸…é›¶æ¬¡æ•° *///         12
 115                  { 0x03330201 , &GStr_EventRecordNum.ucEventTimes[1][0] ,   _FALSE , NO_BITS        ,   NO_BITS ,     4 , 
             -      _FALSE ,      _FALSE     , }    ,   ///*è´­ç”µäº‹ä»¶æ¬¡æ•° *///     13
 116                  { 0x04001001 , GStr_MoneyPara. ucaAlarmMoneyL1  ,     _TRUE  , LIB_E2P_Money_Para  ,   0       ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   ///*ä¸€çº§æŠ¥è­¦ *///     14
 117                  { 0x04001002 , GStr_MoneyPara. ucaAlarmMoneyL2  ,     _TRUE  , LIB_E2P_Money_Para  ,   4       ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   ///*äºŒçº§æŠ¥è­¦ *///     15
 118                  { 0x04001004 , GStr_MoneyPara. ucaMaxMoneyLimit ,     _TRUE  , LIB_E2P_Money_Para  ,   8       ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   ///*å›¤ç§¯é‡‘é¢ *///     16
 119                  { 0x04001003 , GStr_MoneyPara.ucaTickMoneyLimit ,     _TRUE  , LIB_E2P_Money_Para  ,   12      ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   ///*é€æ”¯é‡‘é¢ *///     17
 120                  { 0x04001005 , GStr_MoneyPara.ucaAllowcloseMoney,     _TRUE  , LIB_E2P_Money_Para  ,   16      ,     4 , 
             -      _TRUE  ,      _FALSE     , }    ,   ///*åˆé—¸å…è®¸é‡‘é¢ */// 18
 121                  { 0x04090B01 , GStr_MoneyPara.ucaOverLoadVal    ,     _TRUE  , LIB_E2P_Money_Para  ,   20      ,     3 , 
             -      _TRUE  ,      _FALSE     , }    ,   ///*è¿‡è½½åŠŸç‡ *///     19
 122              { 0x04800010 , GT_ucaFactoryVerNo               ,     _FALSE , NO_BITS             ,   NO_BITS ,     8
             - ,       _FALSE ,      _TRUE      , } ,   ///*å†…éƒ¨ç‰ˆæœ¬å· *///   20
 123              { 0x0400040D , GT_ucaProtocolVer                ,     _FALSE , NO_BITS             ,   NO_BITS ,     1
             -6,       _FALSE ,      _TRUE      , } ,   ///*åè®®ç‰ˆæœ¬å· *///    21
 124              { 0x0400040B , GT_ucaMaterType                  ,     _FALSE , NO_BITS             ,   NO_BITS ,     1
             -0,       _FALSE ,      _TRUE      , } ,   ///*ç”µè¡¨å‹å· *///               22
 125              { 0x04000C01 , NO_BITS                          ,     _TRUE  , LIB_E2P_Password    ,   0       ,     4
             - ,       _FALSE ,      _TRUE      , } ,   ///*00å¯†ç  *///       23
 126              { 0x04000C02 , NO_BITS                          ,     _TRUE  , LIB_E2P_Password    ,   3       ,     4
             - ,      _FALSE ,      _TRUE      , }  ,   ///*01å¯†ç  *///         24
 127              { 0x04000C03 , NO_BITS                          ,     _TRUE  , LIB_E2P_Password    ,   6       ,     4
             - ,      _FALSE ,      _TRUE      , }  ,   ///*02å¯†ç  *///         25
 128                  { 0x04000308 , &GStr_DisplayPara.ucFullDisp_Time,     _TRUE  , LIB_E2P_Display_Para,   0       ,     1 , 
             -     _TRUE  ,      _TRUE      , }     ,   ///*ä¸Šç”µå…¨æ˜¾æ—¶é—´ */// 26      
 129                  { 0x04000302 , &GStr_DisplayPara.ucDispDurTime  ,     _TRUE  , LIB_E2P_Display_Para,   1       ,     1 , 
             -     _TRUE  ,      _TRUE      , }     ,   ///*æ¯å±æ˜¾ç¤ºæ—¶é—´ */// 27
 130                  { 0x04000301 , &GStr_DisplayPara.ucAutoDispNum  ,     _TRUE  , LIB_E2P_Display_Para,   2       ,     1 , 
             -     _TRUE  ,      _TRUE      , }     ,   ///*å¾ªç¯æ˜¾ç¤ºå±æ•° */// 28      
 131                  { 0x04000305 , &GStr_DisplayPara.ucKeyDispNum   ,     _TRUE  , LIB_E2P_Display_Para,   3       ,     1 , 
             -     _TRUE  ,      _TRUE      , }     ,   ///*æŒ‰é”®æ˜¾ç¤ºå±æ•° */// 29      
 132                  { 0x04040101 , GStr_DisplayPara.ucAutoDisptable ,     _TRUE  , LIB_E2P_Display_Table,  0      ,     1 ,  
             -     _FALSE ,      _TRUE       , }    ,   ///*å¾ªç¯æ˜¾ç¤ºé¡¹ç¬¬ä¸€å± *30///   2~30å±   æ•°æ®æ ‡è¯†+1,E2åç§»+1   
 133                  { 0x04040201 , GStr_DisplayPara.ucKeyDisptable  ,     _TRUE  , LIB_E2P_Display_Table,  30     ,     1 ,  
             -     _FALSE ,      _TRUE       , }    ,   ///*æŒ‰é”®æ˜¾ç¤ºé¡¹ç¬¬ä¸€å± *31///   2~30å±   æ•°æ®æ ‡è¯†+1,E2åç§»+1   
 134                  { 0x04000306 , GStr_MeterIFO. ucCurrentTrans,             _TRUE  , LIB_E2P_METER_INFO,     21     ,     3 ,      
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 4   

             - _TRUE  ,      _FALSE      , } ,    ///ç”µæµäº’æ„Ÿå™¨å˜æ¯”
 135                  { 0x04000307 , GStr_MeterIFO. ucVoltageTrans,             _TRUE  , LIB_E2P_METER_INFO,     18     ,     3 ,      
             - _TRUE  ,      _FALSE      , } ,    ///ç”µå‹äº’æ„Ÿå™¨å˜æ¯”
 136                  { 0x02010100,   &GStr_UIPDisplay.ucCOMMVoltageA[2],       _FALSE,  NO_BITS,                                NO_BITS,             2,                _TRUE  
             -,                _FALSE      , } ,   ///* 15Aç›¸ç”µå‹
 137                  { 0x02020100,   &GStr_UIPDisplay.ucCOMMCurrentA[1],       _FALSE,  NO_BITS,                                NO_BITS,             3,                _TRUE  
             -,                _FALSE      , } ,   ///* 16Aç›¸ç”µæµ
 138                  { 0x02030000,   &GStr_UIPDisplay.ucCOMMPower[1],          _FALSE,  NO_BITS,                                NO_BITS,             3,                _TRUE
             -         ,                _FALSE      , } ,   ///* 17æ€»æœ‰åŠŸåŠŸç‡
 139                  { 0x02030100,   &GStr_UIPDisplay.ucCOMMPowerA[1],         _FALSE,  NO_BITS,                                NO_BITS,     3,                _TRUE  
             -,                _FALSE      , } ,   ///* 18Aç›¸æœ‰åŠŸåŠŸç‡,    
 140                  { 0x02060000,   &GStr_UIPDisplay.ucCOMMFactory[2],        _FALSE,  NO_BITS,                                NO_BITS,             2,                _TRUE  
             -,                _FALSE      , } ,   ///* 19æ€»åŠŸç‡å› æ•°
 141                  { 0x02060100,   &GStr_UIPDisplay.ucCOMMFactoryA[2],       _FALSE,  NO_BITS,                                NO_BITS,             2,                _TRUE  
             -,                _FALSE      , } ,   ///* 20Aç›¸åŠŸç‡å› æ•°,    
 142                  { 0x02800002,   &GStr_UIPDisplay.ucFrequency[2],      _FALSE,  NO_BITS,                            NO_BITS,             2,                _TRUE  ,              _
             -FALSE            , } ,   ///* 21Aç”µç½‘é¢‘ç‡,        
 143                  #if(METER_TYPE==METER_TYPE_DTSY666)
                      {0x02010200,    &GStr_UIPDisplay.ucCOMMVoltageB[2],    _FALSE,  NO_BITS,                                   NO_BITS,             2,        _TRUE  ,
             -      _FALSE      , } ,  ///* 22Bç›¸ç”µå‹,   
                      {0x02010300,    &GStr_UIPDisplay.ucCOMMVoltageC[2],    _FALSE,  NO_BITS,                                   NO_BITS,             2,        _TRUE  ,
             -                _FALSE      , } ,  ///* 23Cç›¸ç”µå‹,           
                      {0x02020200,    &GStr_UIPDisplay.ucCOMMCurrentB[1],       _FALSE,  NO_BITS,                                NO_BITS,             3,        _TR
             -UE         ,                _FALSE      , } ,  ///* 24Bç›¸ç”µæµ,   
                      {0x02020300,    &GStr_UIPDisplay.ucCOMMCurrentC[1],       _FALSE,  NO_BITS,                                NO_BITS,             3,        _TRUE  ,
             -                _FALSE      , } ,  ///* 25Cç›¸ç”µæµ,                   
                      {0x02030200,    &GStr_UIPDisplay.ucCOMMPowerB[1]  ,       _FALSE,  NO_BITS,                                NO_BITS,             3,        _TRUE  ,
             -                _FALSE      , } ,  ///* 26Bç›¸æœ‰åŠŸåŠŸç‡
                      {0x02030300,    &GStr_UIPDisplay.ucCOMMPowerC[1]  ,       _FALSE,  NO_BITS,                                NO_BITS,             3,        _TRUE  ,
             -                _FALSE      , } ,  ///* 27Cç›¸æœ‰åŠŸåŠŸç‡,     
                      {0x02060200,    &GStr_UIPDisplay.ucCOMMFactoryB[2],       _FALSE,  NO_BITS,                                NO_BITS,             2,        _TRUE  ,
             -                _FALSE      , } ,  ///* 28BåŠŸç‡å› æ•°
                      {0x02060300,    &GStr_UIPDisplay.ucCOMMFactoryC[2],       _FALSE,  NO_BITS,                                NO_BITS,             2,        _TRUE  ,
             -                _FALSE      , } ,  ///* 29Cç›¸åŠŸç‡å› æ•°,
                      #endif
 153          };                                                                                                        
             -                                
 154          #define MAX_Comm_MAP_TAB        sizeof(Comm_MAP_TAB)/sizeof(GStr_Comm_MAP)
 155          
 156          
 157          const   ulong32 code C_ulaSafeCertification_Code[]={
 158                  0x070000FF,   ///*0  485èº«ä»½è®¤è¯32*///
 159                  0x070001FF,   ///*1  èº«ä»½è®¤è¯æ—¶æ•ˆ14*///
 160                  0x070101FF,   ///*2  å¼€æˆ·30*///
 161                  0x070102FF,   ///*3  ä¸ªäººå……å€¼30*///
 162                  0x070103FF,   ///*4  é’±åŒ…åˆå§‹åŒ–24*///
 163                                                                                          //              0x070104FF,   ///*5  è¡¥åŠ©é‡‘é¢å……å€¼30*///
 164                  0x070301FF,   ///*5  ç§˜é’¥æ›´æ–°48*///
 165                                                                                          //      0x078003FF,   ///*7  çº¢å¤–è®¤è¯è¯·æ±‚16*///
 166                                                                                          //      0x070003FF,       ///*8  çº¢å¤–è®¤è¯å‘½ä»¤16*///
 167                  0x070002FF,   ///*6 èº«ä»½è®¤è¯å¤±æ•ˆè®¾ç½® *///
 168                  // 0x070000EE,   ///*7  485èº«ä»½è®¤è¯32(è‡ªæ‰©æ•°æ®æ ‡è¯†ï¼Œç³»ç»Ÿèº«ä»½è®¤è¯è¿”å›ä¿¡æ¯)*///
 169                  // 0x070102EE,   ///*8  ä¸ªäººå……å€¼30(è‡ªæ‰©æ•°æ®æ ‡è¯†ï¼Œç³»ç»Ÿå……å€¼è¿”å›ä¿¡æ¯)*///
 170          //      0x078001FF,       ///*7 æ•°æ®å›æŠ„ 16 *///
 171          //      0x078102ff        ///*8 çŠ¶æ€æŸ¥è¯¢ 08 *///
 172          };
 173          #define C_SafeCertifiificationCodeNum (sizeof(C_ulaSafeCertification_Code)/4)
 174          const   uchar8  code C_ulaSafeCertification_Len[C_SafeCertifiificationCodeNum]       = {
 175                  32,
 176                  14,
 177                  30,
 178                  30,
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 5   

 179                  24,
 180          //      30,
 181                  48,
 182          //      16,
 183          //      16,
 184                  8,
 185                  // 32,
 186          //      16,
 187          //      8
 188          };
 189          const   uchar8  code C_ulaSafeCertification_ReturnLen[C_SafeCertifiificationCodeNum] = {
 190                  16,
 191                  4 ,
 192                  4 ,
 193                  4 ,
 194                  4 ,
 195          //      4 ,
 196                  4 ,
 197          //      34 ,
 198          //      4,
 199                  22,
 200                  // 16,
 201          //      28,
 202          //      30
 203          };
 204          const   uchar8  code C_ulaSafeCertification_ReturnType[C_SafeCertifiificationCodeNum]= 
 205          {
 206          0x11,
 207          0x00,
 208          0x00,
 209          0x00,
 210          0x00,
 211          //0x00,
 212          0x11,
 213          //0x11,
 214          //0x00,
 215          0x11,
 216          //0x11,
 217          //0x11
 218          };
 219          const   uchar8  code GT_ucVirtualEsam[26][4]= {
 220              0x00,0xB0,0x99,0x01,                                 ///* 0  è·å–ESAMåºåˆ—å·                                        *///
 221                  0x84,0xD4,0x01,0xFF,                             ///* 1  æ›´æ–°å¯†é’¥,å¯†é’¥å­˜E2                                     *///
 222                  0x84,0x30,0x02,0x0C,                             ///* 2  ESAMé’±åŒ…é€€è´¹                                          *///
 223                  0x80,0xFA,0x00,0x03,                             ///* 3  å¯†é’¥åˆ†æ•£å‘½ä»¤                                            *///
 224                  0x80,0xFA,0x00,0x00,                             ///* 4  åŠ å¯†éšæœºæ•°                                            *///
 225                  0x00,0x84,0x00,0x00,                             ///* 5  è·å–éšæœºæ•°                                            *///
 226                  0x84,0xD6,0x96,0x00,                             ///* 6  è®¡ç®—å¯†é’¥æ›´æ–°MAC  æ•°æ®é•¿åº¦0x20ï¼Œ                                *///
 227                  0x04,0xD6,0x82,0x24,                             ///* 7  å¼€æˆ·è®¡ç®—å®¢æˆ·ç¼–å·MAC æ•°æ®é•¿åº¦0x06ï¼Œæ•°æ®å—é•¿åº¦0x0B      
             -*///
 228                  0x04,0xDC,0x01,0x0C,                             ///* 8  è®¡ç®—é¢„ç½®é‡‘é¢MAC                                       *///
 229                  0x04,0xdc,0x03,0x0C,                             ///* 9  è®¡ç®—è´­ç”µæ¬¡æ•°MAC                                       *///
 230                  0x84,0x32,0x01,0x0C,                             ///* 10 è®¡ç®—é’±åŒ…å……å€¼ï¼ˆé’±+æ¬¡æ•°ï¼‰MAC                            *///
 231                  0x04,0xD6,0x82,0x00,                             ///* 11 è®¡ç®—ä¸€ç±»å‚æ•°æ›´æ–°MAC///*æ•°æ®é•¿åº¦-8                     *///
 232                  0x04,0xD6,0x83,0x00,                             ///* 12 è®¡ç®—å½“å‰å¥—ç”µä»·æ›´æ–°MAC                                 *///
 233                  0x04,0xD6,0x84,0x00,                             ///* 13 è®¡ç®—å¤‡ç”¨å¥—ç”µä»·æ›´æ–°MAC                                 *///
 234                  0x00,0x82,0x00,0x08,                             ///* 14 çº¢å¤–éªŒè¯                                              *///
 235                  0x04,0xD6,0x8C,0x00,                             ///* 15 é€€è´¹                                                  *///
 236                  0x04,0xD6,0x00,0x00,                             ///* 16 äºŒç±»å‚æ•°è§£å¯†                                          *///
 237                  0x04,0xD6,0x88,0x00,                             ///* 17 è¿œç¨‹æ§åˆ¶                                               *///
 238                  0x04,0xD6,0x94,0x00,                             ///* 18 ç”µé‡æ¸…é›¶                                              *///
 239                  0x04,0xD6,0x97,0x00,                             ///* 19 äº‹ä»¶æ¸…é›¶                                              *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 6   

 240                  0x00,0xC0,0x00,0x00,                             ///* 20 è¿”å›ä¸Šä¸€æ¬¡æ“ä½œæ•°                                      *///
 241                  0x00,0xB0,0x88,0x00,                             ///* 21 è¿œç¨‹æ§åˆ¶æ•°æ®+9000                                     *///
 242                  0x00,0xB0,0x8C,0x00,                             ///* 22 é€€è´¹æ•°æ®+MAC                                          *///
 243                  0x00,0xB0,0x94,0x00,                             ///* 23 ç”µé‡æ¸…é›¶æ•°æ®                                          *///
 244                  0x00,0xB0,0x97,0x00,                             ///* 24 äº‹ä»¶æ¸…é›¶æ•°æ®                                          *///
 245                  0x04,0xB2,0x01,0x0c,                             ///* 25 å‰©ä½™é‡‘é¢                                          *///
 246          };
 247          
 248          // const ulong32 code C_ulaMultiDataWrite_DI[7]={       ///*å¤šæ•°æ®é¡¹è®¾ç½®(å……å€¼)ï¼Œæ•°æ®æ ‡è¯†*///
 249          //      0x070102FF,                     ///*å……å€¼é‡‘é¢+è´­ç”µæ¬¡æ•°*///
 250          //      0x040501FF,                     ///*ç”µä»·å‚æ•°*///
 251          //      0x04001001,                     ///*æŠ¥è­¦é‡‘é¢1*///
 252          //      0x04001002,                     ///*æŠ¥è­¦é‡‘é¢2*///
 253          //      0x04000306,                     ///*CT*///
 254          //      0x04000307,                     ///*PT*///
 255          //      0x04001003,                     ///*é€æ”¯é‡‘é¢é™å€¼*///
 256          // };
 257          /*----------------< å˜é‡å®šä¹‰ >----------------------------------*/
 258          GU_BoolWordVariable                     GU_SecurityErr;                                         ///* å®‰å…¨è®¤è¯é”™è¯¯å­—//
 259          //uchar8  xdata  GV_ClearFlag;
 260          
 261          /*----------------< å‡½æ•°å£°æ˜ >----------------------------------*/
 262          void ApiDLT645_UARTReceiveDataJudge0( uchar8 v_ucChID, uchar8 v_ucData );
 263          void ApiDLT645_UARTReceiveDataJudge1( uchar8 v_ucChID, uchar8 v_ucData );
 264          void ApiDLT645_FrameAnalysis( uchar8 v_ucChID);
 265          uchar8 PrepaymentModule_Comm_INTAUTH(uchar8 *P_ucDataPtr);
 266          uchar8 PrepaymentModule_Comm_TimeAvailableIn(uchar8 *P_DataPtr);
 267          uchar8 PrepaymentModule_Comm_INTAUTH_Invalidation(uchar8 *P_DataPtr);
 268          uchar8 PrepaymentModule_Comm_ModifyKey(uchar8 *P_DataPtr);
 269          uchar8 PrepaymentModule_Comm_OpenAccout(uchar8 *P_DataPtr);
 270          uchar8 PrepaymentModule_CommWriteESAMBinaryMAC(uchar8 *P_ucData, uchar8 V_ucLen, uchar8 V_ucHeadNum, uchar
             -8 V_ucType);
 271          uchar8 PrepaymentModule_Comm_HandBackMoney(uchar8 *P_DataPtr);
 272          
 273          static uchar8 ApiDLT645_AddrTypeCheck( uchar8 v_ucChID );
 274          static uchar8 ApiDLT645_ReadMeterAddress( uchar8 v_ucChID );
 275          static uchar8 ApiDLT645_WriteMeterAddress( uchar8 v_ucChID );
 276          static uchar8 ApiDLT645_ReadEmuReg( uchar8 v_ucChID );
 277          static uchar8 ApiDLT645_WriteEmuReg( uchar8 v_ucChID );
 278          static uchar8 ApiDLT645_FactoryCommand( uchar8 v_ucChID );
 279          static uchar8 ApiDLT645_ReadData07( uchar8 v_ucChID );
 280          //static uchar8 ApiDLT645_ReadData97( uchar8 v_ucChID );
 281          //static uchar8 ApiDLT645_SetBaudRate( uchar8 v_ucChID);
 282          static uchar8 ApiDLT645_WriteData( uchar8 v_ucChID);
 283          static uchar8 ApiDLT645_MeterClear( uchar8 v_ucChID);
 284          //static uchar8 ApiDLT645_ModifyPsw( uchar8 v_ucChID );
 285          static uchar8 ApiDLT645_RelayControl(uchar8 v_ucChID);
 286          static uchar8 ApiDLT645_SafeCertification( uchar8 v_ucChID );
 287          static uchar8 ApiDLT645_ModifyPsw(uchar8  v_ucChID );
 288          static uchar8 ApiDLT645_AccountTx(uchar8  v_ucChID );
 289          static ushort16 ApiDLT645_GetStatusFlag3(void);
 290          //static uchar8 MultiDataRead_Deal( uchar8 v_ucChID );  //å¤šæ•°æ®é¡¹ç»„åˆæŠ„è¯»
 291          static uchar8 MultiDataWrite_Deal( uchar8 v_ucChID );   //å¤šæ•°æ®é¡¹ç»„åˆè®¾ç½®
 292          
 293          /*----------------< å‡½æ•°å®šä¹‰ >----------------------------------*/
 294          
 295          
 296          
 297          ///**********************************************************************///
 298          ///* Brief:  645æ¥æ”¶æ•°æ®å¸§åˆ¤æ–­                                           *///
 299          ///*                                                                    *///
 300          ///* Param:  v_ucChIDï¼šé€šé“                                               *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 7   

 301          ///* Param:  v_ucDataï¼šæ¥æ”¶åˆ°çš„æ•°æ®                                      *///
 302          ///*                                                                    *///
 303          ///* Return: æ—                                                          *///
 304          ///*                                                                    *///
 305          ///* Note:   UART0ä¸­è°ƒç”¨                                              *///
 306          ///* FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 C  L  D  CS 16 *///
 307          ///**********************************************************************///
 308          void ApiDLT645_UARTReceiveDataJudge0( uchar8 v_ucChID, uchar8 v_ucData )
 309          {
 310   1              
 311   1                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_RECV;  ///* ä¸²å£å¤„äºæ¥æ”¶çŠ¶æ€ *///
 312   1                      Gstr_UartComm[v_ucChID].ulCommRcvByteOverTime = LibPub_GetTimerBeatInt0() ;///* æ¥æ”¶å­—èŠ‚è¶…æ—¶ *///
 313   1              
 314   1                      switch ( Gstr_UartComm[v_ucChID].ucCommRevStep )
 315   1                      {
 316   2                              ///* æ˜¯å¦æ¥æ”¶åˆ°ç¬¬ä¸€ä¸ª68H *///
 317   2                              case API_COMM_STEP0:
 318   2                              {
 319   3                                      if ( v_ucData == 0x68 )
 320   3                                      {
 321   4                                              Gstr_UartComm[v_ucChID].ucCommRevLen = 4;
 322   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP1 ;
 323   4                                      }
 324   3                                      // else
 325   3                                      // {
 326   3                                      //      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 327   3                                      // }
 328   3                                      
 329   3                              }break;
 330   2                              
 331   2                              ///* æ¥æ”¶é€šä¿¡åœ°å€ *///
 332   2                              case API_COMM_STEP1:
 333   2                              {
 334   3                                      if ( Gstr_UartComm[v_ucChID].ucCommRevLen >= 10 )
 335   3                                      {
 336   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP2 ;
 337   4                                      }
 338   3                              }break;
 339   2                              
 340   2                              ///* åˆ¤æ–­ç¬¬2ä¸ª68H *///
 341   2                              case API_COMM_STEP2:
 342   2                              {
 343   3                                      if (  0x68 == v_ucData )
 344   3                                      {
 345   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP3 ;
 346   4                                      }
 347   3                                      else
 348   3                                      {
 349   4                                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 350   4                                      }
 351   3                              }break;
 352   2                              
 353   2                              ///* æ¥æ”¶æ§åˆ¶å­— *///
 354   2                              case API_COMM_STEP3:
 355   2                              {
 356   3                                      Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP4 ;
 357   3                              }break;
 358   2                              
 359   2                              ///* æ¥æ”¶æ•°æ®é•¿åº¦ *///
 360   2                              case API_COMM_STEP4:
 361   2                              {
 362   3                                      if ( 0x00 == v_ucData )
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 8   

 363   3                                      {
 364   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP6 ;        ///* é•¿åº¦æ˜¯0ï¼Œç›´æ¥æ¥æ”¶CS *///
 365   4                                      }
 366   3                                      else
 367   3                                      {
 368   4                                              if ( API_COMM_BUF_MAX_LEN-12 < v_ucData )       ///* æ•°æ®é•¿åº¦è¶…å‡ºç¼“å­˜å¤§å° *///
 369   4                                              {
 370   5                                                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 371   5                                              }
 372   4                                              else
 373   4                                              { 
 374   5                                                      Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP5 ;
 375   5                                              }
 376   4                                      }
 377   3                              }break;
 378   2                              
 379   2                              ///* æ¥æ”¶æ•°æ® *///
 380   2                              case API_COMM_STEP5:
 381   2                              {
 382   3                                      if ( Gstr_UartComm[v_ucChID].ucCommRevLen == Gstr_UartComm[v_ucChID].ucaCommRXBuff[API_DLT645_LEN] + 9
             - + 4 ) 
 383   3                                      {
 384   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP6 ;
 385   4                                      }
 386   3                              }break;
 387   2                              
 388   2                              ///* æ¥æ”¶CS *///
 389   2                              case API_COMM_STEP6:
 390   2                              {
 391   3                                      Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP7;
 392   3                              }break;
 393   2                              
 394   2                              ///* æ¥æ”¶16 *///
 395   2                              case API_COMM_STEP7:
 396   2                              {
 397   3                                      if ( 0x16 != v_ucData )
 398   3                                      {
 399   4                                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 400   4                                      }
 401   3                                      else
 402   3                                      {
 403   4                                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_RECV_OK;               ///* æ•°æ®æ¥æ”¶å®Œæˆ *///
 404   4                                              Gstr_UartComm[v_ucChID].ulCommRspOverTime = LibPub_GetTimerBeatInt0() ;         ///* å¯åŠ¨å“åº”è¶…æ—¶ *///
 405   4                                              GStr_DisplayPara.ucDisp_tongxin_Time=LibPub_GetTimerBeatInt0() ;
 406   4                                              GStr_DisplayPara.ucDisp_tongxin_Flag=0x55;///æ¥æ”¶å®Œæˆé—ªçƒæ˜¾ç¤ºé€šä¿¡ç¬¦å·
 407   4                                              
 408   4                                      }
 409   3                              }break;
 410   2                              
 411   2                              default:
 412   2                              {
 413   3                                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 414   3                              }break;
 415   2                      }
 416   1                                      
 417   1                      
 418   1                      if ( API_COMM_STATUS_ERROR != Gstr_UartComm[v_ucChID].ucCommChStatus )
 419   1                      {
 420   2                              Gstr_UartComm[v_ucChID].ucaCommRXBuff[Gstr_UartComm[v_ucChID].ucCommRevLen] = v_ucData;
 421   2                              Gstr_UartComm[v_ucChID].ucCommRevLen++ ; 
 422   2                      }
 423   1      }
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 9   

 424          ///**********************************************************************///
 425          ///* Brief:  645æ¥æ”¶æ•°æ®å¸§åˆ¤æ–­                                           *///
 426          ///*                                                                    *///
 427          ///* Param:  v_ucChIDï¼šé€šé“                                               *///
 428          ///* Param:  v_ucDataï¼šæ¥æ”¶åˆ°çš„æ•°æ®                                      *///
 429          ///*                                                                    *///
 430          ///* Return: æ—                                                          *///
 431          ///*                                                                    *///
 432          ///* Note:   UART1ä¸­è°ƒç”¨,ä¸ºäº†æ¶ˆé™¤ç¼–è¯‘å™¨æŠ¥è­¦ï¼Œ                           *///
 433          ///*è“ç‰™æ•°æ®å¸§ç»“æ„FE FE FE FE 68H L1 L2 M5-M0 STA1 RES2 68H C D0-Dn CS 16H*///
 434          ///**********************************************************************///
 435          void ApiDLT645_UARTReceiveDataJudge1( uchar8 v_ucChID, uchar8 v_ucData )
 436          {
 437   1              
 438   1                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_RECV;  ///* ä¸²å£å¤„äºæ¥æ”¶çŠ¶æ€ *///
 439   1                      Gstr_UartComm[v_ucChID].ulCommRcvByteOverTime = LibPub_GetTimerBeatInt1() ;///* æ¥æ”¶å­—èŠ‚è¶…æ—¶ *///
 440   1              
 441   1                      switch ( Gstr_UartComm[v_ucChID].ucCommRevStep )
 442   1                      {
 443   2                              ///* æ˜¯å¦æ¥æ”¶åˆ°ç¬¬ä¸€ä¸ª68H *///
 444   2                              case API_COMM_STEP0:
 445   2                              {
 446   3                                      if ( v_ucData == 0x68 )
 447   3                                      {
 448   4                                              Gstr_UartComm[v_ucChID].ucCommRevLen = 4;
 449   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP1 ;
 450   4                                      }
 451   3                                      
 452   3                              }break;
 453   2                              
 454   2                              ///* æ¥æ”¶é•¿åº¦ä½8ä½ï¼ˆé•¿åº¦æœ‰ä¸¤ä¸ªå­—èŠ‚ï¼Œç”±äºç¼“å­˜é™å€¼é«˜8ä½ä¸º0ï¼‰ *///
 455   2                              case API_COMM_STEP1:
 456   2                              {
 457   3                                      if ( API_COMM_BUF_MAX_LEN-19 < v_ucData )       ///* æ•°æ®é•¿åº¦è¶…å‡ºç¼“å­˜å¤§å°,é•¿åº¦ä¸å¯èƒ½ä¸º0 *///
 458   3                                      {
 459   4                                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 460   4                                      }
 461   3                                      Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP2 ;
 462   3                              }break;
 463   2      
 464   2                              ///* æ¥æ”¶é•¿åº¦é«˜8ä½ã€MACåœ°å€ã€é“¾è·¯çŠ¶æ€ã€é¢„ç•™ã€åˆ¤æ–­ç¬¬2ä¸ª68H *///
 465   2                              case API_COMM_STEP2:
 466   2                              {
 467   3                                      if (( Gstr_UartComm[v_ucChID].ucCommRevLen >= 15 )&&(  0x68 == v_ucData ))
 468   3                                      {
 469   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP3 ;
 470   4                                      }
 471   3                              }break;
 472   2                              
 473   2                              ///* æ¥æ”¶è“ç‰™åè®®æ§åˆ¶å­—ï¼Œå› ä¸ºæ˜¯é€ä¼ åªèƒ½æ˜¯0x00å’Œ0xFF *///
 474   2                              case API_COMM_STEP3:
 475   2                              {
 476   3                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP4 ;
 477   3                              }break;
 478   2                                                      
 479   2                              ///* æ¥æ”¶æ•°æ® *///
 480   2                              case API_COMM_STEP4:
 481   2                              {
 482   3                                      if ( Gstr_UartComm[v_ucChID].ucCommRevLen == Gstr_UartComm[v_ucChID].ucaCommRXBuff[API_DLT645_BLELENLS
             -B] + 16 ) 
 483   3                                      {
 484   4                                              Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP5 ;
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 10  

 485   4                                      }
 486   3                              }break;
 487   2                              
 488   2                              ///* æ¥æ”¶CS *///
 489   2                              case API_COMM_STEP5:
 490   2                              {
 491   3                                      Gstr_UartComm[v_ucChID].ucCommRevStep = API_COMM_STEP6;
 492   3                              }break;
 493   2                              
 494   2                              ///* æ¥æ”¶16 *///
 495   2                              case API_COMM_STEP6:
 496   2                              {
 497   3                                      if ( 0x16 != v_ucData )
 498   3                                      {
 499   4                                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 500   4                                      }
 501   3                                      else
 502   3                                      {
 503   4                                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_RECV_OK;               ///* æ•°æ®æ¥æ”¶å®Œæˆ *///
 504   4                                              Gstr_UartComm[v_ucChID].ulCommRspOverTime = LibPub_GetTimerBeatInt1() ;         ///* å¯åŠ¨å“åº”è¶…æ—¶ *///
 505   4                                              GStr_DisplayPara.ucDisp_tongxin_Time=LibPub_GetTimerBeatInt1() ;
 506   4                                              GStr_DisplayPara.ucDisp_tongxin_Flag=0x55;///æ¥æ”¶å®Œæˆé—ªçƒæ˜¾ç¤ºé€šä¿¡ç¬¦å·
 507   4                                              /* åˆ¤æ–­æ˜¯å¦ä¸ºæ¨¡å—ä¸»åŠ¨ä¸ŠæŠ¥è¿æ¥ä¿¡æ¯ï¼›æ§åˆ¶ç ä¸º0x82ï¼Œç›®æ ‡è®¾å¤‡åœ°å€ä¸ºå…¨F */
 508   4                                              if( (Gstr_UartComm[v_ucChID].ucaCommRXBuff[16] == 0x82)&&!(LibPub_0xFFCheckInt(&Gstr_UartComm[v_ucChI
             -D].ucaCommRXBuff[API_DLT645_MACADDRLSB], 6)) )
 509   4                                              {
 510   5                                                      if( Gstr_UartComm[v_ucChID].ucaCommRXBuff[API_DLT645_BLELENLSB] == 0x0A)
 511   5                                                      {
 512   6                                                              GStr_Monitor.ucBleConnectCnt = 0;                               /* ä¸ŠæŠ¥ç›´æ¥å°†å¿ƒè·³è®¡æ•°æ¸…é›¶ï¼Œé¿å…å¿«é€Ÿæ–­å¼€è¿æ
             -¥å¯¼è‡´åˆ¤æ–­ä¸åŠæ—¶*/
 513   6                                                              GStr_Flag.ucBLESTATFlag = BLE_STAT_CONNECTED;   /* å·²è¿æ¥çŠ¶æ€ */
 514   6                                                      }
 515   5                                                      else if(( Gstr_UartComm[v_ucChID].ucaCommRXBuff[API_DLT645_BLELENLSB] == 0x05)||( Gstr_UartComm[v_uc
             -ChID].ucaCommRXBuff[API_DLT645_BLELENLSB] == 0x04))
 516   5                                                      {
 517   6                                                              GStr_Flag.ucBLESTATFlag = BLE_STAT_IDLE;                /* ç©ºé—²çŠ¶æ€ */
 518   6                                                      }
 519   5                                                      else
 520   5                                                      {
 521   6                                                              GStr_Flag.ucBLESTATFlag = BLE_STAT_ERRREP;              /* æ¨¡å—è¿æ¥ä¸ŠæŠ¥å¼‚å¸¸ */
 522   6                                                      }
 523   5                                              }
 524   4                                      }
 525   3                              }break;
 526   2                              
 527   2                              default:
 528   2                              {
 529   3                                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 530   3                              }break;
 531   2                      }
 532   1                                      
 533   1                      
 534   1                      if ( API_COMM_STATUS_ERROR != Gstr_UartComm[v_ucChID].ucCommChStatus )
 535   1                      {
 536   2                              Gstr_UartComm[v_ucChID].ucaCommRXBuff[Gstr_UartComm[v_ucChID].ucCommRevLen] = v_ucData;
 537   2                              Gstr_UartComm[v_ucChID].ucCommRevLen++ ; 
 538   2                      }
 539   1      }
 540          
 541          ///**********************************************************************///
 542          ///* Brief:  645å¸§è§£æ                                                  *///
 543          ///*                                                                    *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 11  

 544          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
 545          ///*                                                                    *///
 546          ///* Return: æ—                                                          *///
 547          ///*                                                                    *///
 548          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
 549          ///**********************************************************************///
 550          void ApiDLT645_FrameAnalysis( uchar8 v_ucChID)
 551          {
 552   1              uchar8  V_ucTemp;               /*1å­—èŠ‚ä¸´æ—¶å˜é‡ï¼Œå³ç”¨å³æ¶ˆ*/
 553   1              uchar8  V_ucCnt_i;              /*ç”¨äºè®¡ç®—å­˜æ”¾CS*/
 554   1              uchar8  BLE_head_Frame[20]="";
 555   1      
 556   1              /*æ¥æ”¶ç¼“å­˜æ‹·è´åˆ°å‘é€ç¼“å­˜ä¸­*/
 557   1              if ( CH_UART_UART0 == v_ucChID) // ç›®å‰æ˜¯485
 558   1              {
 559   2                      LibPub_MemCopyBytes( &Gstr_UartComm[v_ucChID].ucaCommRXBuff[0], &Gstr_UartComm[v_ucChID].ucaCommTXBuff[0
             -], Gstr_UartComm[v_ucChID].ucaCommRXBuff[API_DLT645_LEN]+16 );
 560   2              }
 561   1      
 562   1              if ( CH_UART_UART1 == v_ucChID) // ç›®å‰æ˜¯è“ç‰™
 563   1              {
 564   2                      LibPub_MemCopyBytes( &Gstr_UartComm[v_ucChID].ucaCommRXBuff[17], &Gstr_UartComm[v_ucChID].ucaCommTXBuff[
             -0], Gstr_UartComm[v_ucChID].ucaCommRXBuff[5] );       /*ucaCommTXBuff[5]ä¸º645æ•°æ®å¸§çš„é•¿åº¦      */                              
 565   2              }
 566   1              
 567   1              ///* å…ˆåˆ¤æ–­ä¸€ä¸‹é€šä¿¡åœ°å€ *///   
 568   1              Gstr_UartComm[v_ucChID].ucCommAddrType = ApiDLT645_AddrTypeCheck(v_ucChID);
 569   1              if ( F_COMMADDRTYPE_NULL == Gstr_UartComm[v_ucChID].ucCommAddrType )
 570   1              {
 571   2                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 572   2                      return;
 573   2              }       
 574   1              
 575   1              ///* ç®—ä¸€ä¸‹CSå’Œ-33å¤„ç† *///
 576   1              V_ucTemp = LibPub_CalSum( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1ST68H], Gstr_UartComm[v_ucCh
             -ID].ucaCommTXBuff[API_DLT645_LEN] + 10) ;
 577   1              for( V_ucCnt_i = 0; V_ucCnt_i < Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]; V_ucCnt_i++ )
 578   1              {
 579   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+V_ucCnt_i] -= 0x33;
 580   2              }        
 581   1              if ( V_ucTemp != Gstr_UartComm[v_ucChID].ucaCommTXBuff[V_ucCnt_i+API_DLT645_1STDATA])///* åˆ¤æ–­ä¸€ä¸‹CS 
             -*///
 582   1              {
 583   2                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 584   2                      return;
 585   2              }
 586   1              
 587   1              ///* ä»¥ä¸‹æ•°æ®æ­£å¸¸ï¼Œå¯ä»¥æ­£å¸¸è§£æäº† *///
 588   1              ///*å…ˆä¿å­˜ä¸‹æ“ä½œè€…ä»£ç å’Œæ•°æ®æ ‡è¯†ç”¨äºç¼–ç¨‹è®°å½•
 589   1              if(Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ]!=API_DLT645_CMD_Safe_Certification)
 590   1              {
 591   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_C0 ], &GA_ucOperCode[0], 4);
 592   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_DI0 ], &GA_ucDICode[0], 4);
 593   2              }
 594   1              else////03å‘½ä»¤æ²¡æœ‰å¯†ç ï¼Œæ‰€ä»¥æ“ä½œè¿™ä»£ç ä¸º18ä½å¼€å§‹
 595   1              {
 596   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_PA0 ], &GA_ucOperCode[0], 4);
 597   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_DI0 ], &GA_ucDICode[0], 4);
 598   2              }
 599   1              
 600   1              GStr_Monitor.ucBleConnectCnt = 0;       /* ç¬¦åˆ645å¸§æ ¼å¼å°±å°†è¿æ¥è®¡æ—¶å™¨æ¸…é›¶ï¼Œè¯æ˜è“ç‰™å¿ƒè·³æ­
             -£å¸¸ */        
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 12  

 601   1              
 602   1              switch ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ] )
 603   1              {
 604   2                      case    API_DLT645_CMD_Safe_Certification:      ///*èº«ä»½è®¤è¯   *////
 605   2                      {
 606   3                                      V_ucTemp = ApiDLT645_SafeCertification( v_ucChID );
 607   3                      }break;
 608   2                              
 609   2                      case    API_DLT645_CMD_RD_METER_ADDR:                   ///* å…¨Aè¯»é€šä¿¡åœ°å€ *///
 610   2                      {
 611   3                                      V_ucTemp = ApiDLT645_ReadMeterAddress( v_ucChID );
 612   3                      }break;
 613   2                      
 614   2                      
 615   2                      case    API_DLT645_CMD_WR_METER_ADDR:                   ///* å…¨Aå†™é€šä¿¡åœ°å€ *///
 616   2                      {
 617   3                                      V_ucTemp = ApiDLT645_WriteMeterAddress( v_ucChID );
 618   3                      }break;
 619   2                      
 620   2                      case    API_DLT645_CMD_RD_EMU_REG:                              ///* è¯»emuå¯„å­˜å™¨åœ°å€ *///
 621   2                      {
 622   3                                      V_ucTemp =  ApiDLT645_ReadEmuReg( v_ucChID );
 623   3                      }break;
 624   2                      
 625   2                      case    API_DLT645_CMD_WR_EMU_REG:                              ///* å†™emuå¯„å­˜å™¨åœ°å€ *///
 626   2                      {
 627   3                                      V_ucTemp =  ApiDLT645_WriteEmuReg( v_ucChID );
 628   3                      }break;
 629   2                      
 630   2                      case  API_DLT645_CMD_RELAY_CTRL:               ///* è´¹æ§å‘½ä»¤
 631   2                      {
 632   3                              LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R],GA_ucRelayOperCode,4);
 633   3                              V_ucTemp =  ApiDLT645_RelayControl( v_ucChID );
 634   3                      }break;
 635   2                      
 636   2                      case    API_DLT645_CMD_FACTORY_1E:                              ///* å‚å†…è‡ªæ‰©å‘½ä»¤ *///
 637   2                      case    API_DLT645_CMD_FACTORY_1F:      
 638   2                      {
 639   3                                      V_ucTemp =  ApiDLT645_FactoryCommand( v_ucChID );
 640   3                      }break;
 641   2                              
 642   2                      case    API_DLT645_CMD_RD_DATA07:                               ///* 07è¯»æ•°æ® *///
 643   2                      {
 644   3                                      V_ucTemp =  ApiDLT645_ReadData07( v_ucChID );
 645   3                      }break;
 646   2                      
 647   2                      case    API_DLT645_CMD_WR_DATA07:                               ///* 07å†™æ•°æ® *///
 648   2                      {
 649   3                                      V_ucTemp =  ApiDLT645_WriteData( v_ucChID );
 650   3                      }break;
 651   2                      
 652   2                      case    API_DLT645_CMD_METER_CLR:                               ///* 07ç”µè¡¨æ¸…é›¶ *///
 653   2                      {
 654   3                                      V_ucTemp =  ApiDLT645_MeterClear( v_ucChID );
 655   3                      }break;
 656   2                      
 657   2                      case    API_DLT645_CMD_WR_SET_PSW:                              ///* ä¿®æ”¹å¯†ç  *///
 658   2                      {
 659   3                                      V_ucTemp =  ApiDLT645_ModifyPsw( v_ucChID );                    
 660   3                      }break;
 661   2                      
 662   2                      case    API_DLT645_CMD_Account_Transaction:             ///* ç³»ç»Ÿè‡ªæ‰©å‘½ä»¤ *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 13  

 663   2                      {
 664   3                                      V_ucTemp =  ApiDLT645_AccountTx( v_ucChID );
 665   3                      }break;
 666   2                      
 667   2                      default:break;
 668   2              }
 669   1              
 670   1              ///* æ ¹æ®å¤„ç†ç»“æœç»„ç»‡éœ€è¦è¿”å›çš„æ•°æ® */// 
 671   1              switch( V_ucTemp )
 672   1              {
 673   2                      case API_DLT645_COMM_ERR_OK:    ///* æ­£å¸¸åº”ç­” *///
 674   2                      {
 675   3                              if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ] ==API_DLT645_CMD_WR_DATA07)||(Gstr_UartComm
             -[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ] ==API_DLT645_CMD_Safe_Certification))
 676   3                              {
 677   4                                      if(!(GStr_Flag.ucRunState2 &F_RUN_PROG_10MIN_FLAG))
 678   4                                      {
 679   5                                              GStr_Monitor.ulProgEventDelayTime=LibPub_GetTimerBeat();///10minå®šæ—¶
 680   5                                              GStr_Flag.ucRunState2|=F_RUN_PROG_10MIN_FLAG;///ç½®10minå®šæ—¶æ ‡å¿—
 681   5                                              GStr_Flag.ucRunState2|=F_RUN_FirstProgFlag;///ç½®é¦–æ¬¡ç¼–ç¨‹æ ‡å¿—
 682   5                                              ApiEvent_WriteRecord(C_Program);///åšé¦–æ¬¡ç¼–ç¨‹è®°å½•
 683   5                                      }
 684   4                                      else
 685   4                                      {
 686   5                                              GStr_Monitor.ulProgEventDelayTime=LibPub_GetTimerBeat();///10minå®šæ—¶
 687   5                                              GStr_Flag.ucRunState2|=F_RUN_PROG_10MIN_FLAG;///ç½®10minå®šæ—¶æ ‡å¿—
 688   5                                              ApiEvent_WriteRecord(C_Program);///åšç¼–ç¨‹è®°å½•      
 689   5                                      }
 690   4                              }
 691   3                              
 692   3                               Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ] |= 0x80;
 693   3                      }break;
 694   2                      
 695   2                      case API_DLT645_COMM_RD_OK:
 696   2                      {
 697   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ] |= 0x80;
 698   3                      }break;
 699   2                      case API_DLT645_COMM_WR_OK:     ///*ä¿®æ”¹å¯†ç æ­£ç¡®*///
 700   2                      {
 701   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[12] |= 0x80;                                                              //æ§åˆ¶ç 
 702   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[13]  = 0x04;                                                              //æ•°æ®é•¿åº¦
 703   3                      }break;
 704   2                      ///* æœ‰é”™è¯¯ *///
 705   2                      case API_DLT645_COMM_ERR_OTHER:
 706   2                      case API_DLT645_COMM_ERR_NODATA:
 707   2                      case API_DLT645_COMM_ERR_NOAUTH:
 708   2                      case API_DLT645_COMM_ERR_BPSERR:
 709   2                      {
 710   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ] |= 0xC0;
 711   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_LEN ]  = 0x01;
 712   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_1STDATA ]  = V_ucTemp;
 713   3                              
 714   3                      }break;
 715   2                      
 716   2                      ///* ä¸åº”ç­” *///
 717   2                      case API_DLT645_COMM_ERR_NOACK:
 718   2                      {
 719   3                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR; 
 720   3                      }break;
 721   2                      ///èº«ä»½è®¤è¯å¤±è´¥
 722   2                      case API_DLT645_SAFE_CERT_ERR:
 723   2                      {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 14  

 724   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_CMD ] |= 0xC0;
 725   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_LEN ]  = 0x02;
 726   3                              // Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_1STDATA ]  = GU_SecurityErr.BYTE[0];
 727   3                              // Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_1STDATA+1 ]  = GU_SecurityErr.BYTE[1];
 728   3                      }break;
 729   2                      
 730   2                      
 731   2                      default:
 732   2                      {
 733   3                              Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_ERROR;
 734   3                      }break;
 735   2              }
 736   1              
 737   1              if ( Gstr_UartComm[v_ucChID].ucCommChStatus != API_COMM_STATUS_ERROR )
 738   1              {
 739   2                      ///* ç»„ç»‡è¦è¿”å›çš„æ•°æ® *///
 740   2                      Gstr_UartComm[v_ucChID].ucCommSndCnt = 0;
 741   2                      
 742   2                      LibPub_MemSetBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_1STFE ], 0xFE, 4 );      ///* ç»„ç»‡4ä
             -¸ªFE *///
 743   2                      LibPub_MemExchangeBytes( &GStr_MeterIFO.ucaCommAddr[0], &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT64
             -5_ADDRLSB], 6);       ///* é€šä¿¡åœ°å€ *///
 744   2                      
 745   2                      for( V_ucCnt_i = 0; V_ucCnt_i < Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_LEN ]; V_ucCnt_i++ )
 746   2                      {
 747   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_1STDATA + V_ucCnt_i ] += 0x33;
 748   3                      }
 749   2                      V_ucTemp = LibPub_CalSum( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1ST68H], Gstr_UartComm[v_ucC
             -hID].ucaCommTXBuff[API_DLT645_LEN] + 10) ;
 750   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[ Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] + API_DLT64
             -5_1STDATA] = V_ucTemp;
 751   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[ Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] + API_DLT64
             -5_1STDATA + 1] = 0x16;
 752   2                      
 753   2                      Gstr_UartComm[v_ucChID].ucCommSndLen = Gstr_UartComm[v_ucChID].ucaCommTXBuff[ API_DLT645_LEN ] + 16;    ///
             -* 485è¦å‘é€çš„æ•°æ®é•¿åº¦ *///
 754   2                      /*ä»¥ä¸‹æ˜¯ç»„ç»‡è“ç‰™ç»“æ„çš„æ•°æ®å¸§é•¿åº¦ã€æ§åˆ¶ç ã€CSã€16*/
 755   2                      if ( CH_UART_UART1 == v_ucChID) // ç›®å‰æ˜¯è“ç‰™
 756   2                      {
 757   3                              for( V_ucCnt_i = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]+API_DLT645_BLE1STDATA; V_ucCnt_i
             - > 0; V_ucCnt_i-- )   /*å°†645æ•°æ®å¸§å¾€åç§»ï¼Œç©ºå‡ºè“ç‰™æ•°æ®çš„å¸§å¤´,API_DLT645_BLE1STDATAä½æ•°æ®*/
 758   3                              {
 759   4                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[ V_ucCnt_i + API_DLT645_BLE1STDATA - 1 ] = Gstr_UartComm[v_ucChI
             -D].ucaCommTXBuff[ V_ucCnt_i-1 ];
 760   4                              }
 761   3      
 762   3                              /*è“ç‰™æ•°æ®å¸§å‰ç¼€*/
 763   3                              LibPub_MemCopyBytes( &C_cBleComm_Head[ API_DLT645_BLE1STFE ], &Gstr_UartComm[v_ucChID].ucaCommTXBuff[ A
             -PI_DLT645_BLE1STFE ], 7 );    
 764   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ 5 ] = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] + AP
             -I_DLT645_BLE1STDATA - 1;      /*è“ç‰™å¸§ç»“æ„çš„æ•°æ®é•¿åº¦ä½ä½*/
 765   3                              LibPub_MemCopyBytes( &Gstr_UartComm[v_ucChID].ucaCommRXBuff[ 7 ], &Gstr_UartComm[v_ucChID].ucaCommTXBuf
             -f[ 7 ], 6 );        /*ç›®æ ‡è“ç‰™Macåœ°å€*/
 766   3                              LibPub_MemCopyBytes( &C_cBleComm_Head[ API_DLT645_BLELinkSTA ], &Gstr_UartComm[v_ucChID].ucaCommTXBuff[
             - API_DLT645_BLELinkSTA ], 4 );        
 767   3      
 768   3                              V_ucTemp = LibPub_CalSum( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[ 4 ], Gstr_UartComm[v_ucChID].ucaCommT
             -XBuff[ 5 ] + 13) ;
 769   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ Gstr_UartComm[v_ucChID].ucaCommTXBuff[ 5 ] + API_DLT645_BLE1STDA
             -TA ] = V_ucTemp;
 770   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[ Gstr_UartComm[v_ucChID].ucaCommTXBuff[ 5 ] + API_DLT645_BLE1STDA
             -TA +1 ] = 0x16;
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 15  

 771   3      
 772   3                              Gstr_UartComm[v_ucChID].ucCommSndLen = Gstr_UartComm[v_ucChID].ucaCommTXBuff[ 5 ] + 19; ///* è“ç‰™è¦å
             -‘é€çš„æ•°æ®é•¿åº¦ *///
 773   3                              GStr_Monitor.ucBleAdvCnt = 0;   //è“ç‰™å®šæ—¶æ ¡éªŒè®¡æ•°æ¸…é›¶ï¼Œæœ‰è“ç‰™é€šä¿¡å°±æ¸…é›¶
 774   3                      }
 775   2                      
 776   2                      ///* æ•°æ®å‡†å¤‡å¥½äº†å°±å¯ä»¥å‘é€äº† *///
 777   2                      Gstr_UartComm[v_ucChID].ucCommChStatus = API_COMM_STATUS_FRAME_OK;
 778   2              } 
 779   1              
 780   1      }
 781          ///**********************************************************************///
 782          ///* Brief:  è¯»é€šä¿¡åœ°å€                                                  *///
 783          ///*                                                                    *///
 784          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
 785          ///*                                                                    *///
 786          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
 787          ///*                                                                    *///
 788          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
 789          ///**********************************************************************///
 790          static uchar8 ApiDLT645_ReadMeterAddress( uchar8 v_ucChID )
 791          {
 792   1              uchar8  V_ucErrorType = API_DLT645_COMM_ERR_NOACK;      
 793   1      
 794   1              if ( Gstr_UartComm[v_ucChID].ucCommAddrType == F_COMMADDRTYPE_AA )
 795   1              {
 796   2      
 797   2                      LibPub_MemExchangeBytes( &GStr_MeterIFO.ucaCommAddr[0], &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT64
             -5_1STDATA], 6);
 798   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 6;
 799   2                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
 800   2              }
 801   1              
 802   1              return ( V_ucErrorType ) ;
 803   1      }
 804          ///**********************************************************************///
 805          ///* Brief:  å†™é€šä¿¡åœ°å€                                                  *///
 806          ///*                                                                    *///
 807          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
 808          ///*                                                                    *///
 809          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
 810          ///*                                                                    *///
 811          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
 812          ///**********************************************************************///
 813          static uchar8 ApiDLT645_WriteMeterAddress( uchar8 v_ucChID )
 814          {
 815   1              uchar8  V_ucErrorType = API_DLT645_COMM_ERR_NOACK;      
 816   1      //      uchar8  V_ucTempBuff[30];
 817   1              if ( Gstr_UartComm[v_ucChID].ucCommAddrType == F_COMMADDRTYPE_AA )
 818   1              {
 819   2                      if(_FAILED==LibPub_IsBCD(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA],6))
 820   2                      {
 821   3                              V_ucErrorType=API_DLT645_COMM_ERR_OTHER;
 822   3                      }
 823   2                      else
 824   2                      {
 825   3                              if( _SUCCESS == LibPub_ReadDataFromE2prom(LIB_E2P_METER_INFO, 0, &GStr_MeterIFO.ucaCommAddr[0]))
 826   3                              {
 827   4      
 828   4                                      //å…ˆè¯»å–é€šä¿¡åœ°å€æ‰€åœ¨EEçš„æ•´æ¡æ•°æ®ï¼Œç”¨äºåç»­ç®—CRC
 829   4                                      LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA],&GStr_MeterIFO.ucaC
             -ommAddr[0],6);
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 16  

 830   4                                      //æ›´æ–°RAM
 831   4                                      if( _SUCCESS == LibPub_WriteDataToE2prom(LIB_E2P_METER_INFO, 0, &GStr_MeterIFO.ucaCommAddr[0]) ) 
 832   4                                      {
 833   5                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
 834   5                                              GStr_Flag.ucBLESTATFlag = BLE_STAT_MAC_MOD;             //éœ€è¦è®¾ç½®è“ç‰™æ¨¡å—macæ ‡å¿—
 835   5                                              /*å†™å®Œé€šä¿¡åœ°å€åéœ€è¦é‡æ–°è®¾ç½®è“ç‰™æ¨¡å—å‚æ•°ï¼Œå¹¶é‡æ–°å¹¿æ’­*/
 836   5                                              //BleDrv_BleReset();
 837   5                                              //BleDrv_InitBleRunPara();
 838   5                                              //BleDrv_SetBleStat();   
 839   5                                      }
 840   4                                      else
 841   4                                      {
 842   5                                              V_ucErrorType=API_DLT645_COMM_ERR_OTHER;
 843   5                                      }
 844   4                              }
 845   3                              else
 846   3                              {
 847   4                                      V_ucErrorType=API_DLT645_COMM_ERR_OTHER;
 848   4                              }
 849   3                      }               
 850   2              }
 851   1              
 852   1              return ( V_ucErrorType ) ;
 853   1      }
 854          
 855          
 856          ///**********************************************************************///
 857          ///* Brief:  é€šä¿¡åœ°å€ç±»å‹è§£æ                                             *///
 858          ///*                                                                    *///
 859          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
 860          ///*                                                                    *///
 861          ///* Return: é€šä¿¡åœ°å€ç±»å‹ï¼ˆå…¨9ã€å…¨Aã€ç¼©ä½ã€åŒ¹é…)                          *///
 862          ///*                                                                    *///
 863          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
 864          ///**********************************************************************///
 865          uchar8 ApiDLT645_AddrTypeCheck( uchar8 v_ucChID )
 866          {
 867   1              uchar8 i,j,V_ucAddrType = F_COMMADDRTYPE_NULL;
 868   1              
 869   1              for ( i = 0; i < 6; i++ )
 870   1              {
 871   2                      if ( 0x99 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_ADDRLSB+i] )
 872   2                      {
 873   3                              break;
 874   3                      }
 875   2              }
 876   1              
 877   1              if ( 6 == i )
 878   1              {
 879   2                      V_ucAddrType = F_COMMADDRTYPE_99;       ///* å…¨9å¹¿æ’­åœ°å€ *///
 880   2              }
 881   1              else
 882   1              {
 883   2                      for ( i = 0; i < 6; i++ )
 884   2                      {
 885   3                              if ( 0xAA != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_ADDRMSB-i] )
 886   3                              {
 887   4                                      for ( j = i; j < 6; j++ )
 888   4                                      {
 889   5                                              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_ADDRMSB - j] != GStr_MeterIFO.ucaCommAddr[j] )
 890   5                                              {
 891   6                                                      break;
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 17  

 892   6                                              }
 893   5                                      }
 894   4                                      if ( 6 == j )   ///* è¯´æ˜æ˜¯å…¨ç­‰åœ°å€æˆ–è€…æ˜¯ç¼©ä½ *///
 895   4                                      {
 896   5                                              if ( 0 == i )
 897   5                                              {
 898   6                                                      V_ucAddrType = F_COMMADDRTYPE_ID;
 899   6                                              }
 900   5                                              else
 901   5                                              {
 902   6                                                      V_ucAddrType = F_COMMADDRTYPE_SW;
 903   6                                              }
 904   5                                      }
 905   4                                      break;
 906   4                              }
 907   3                      }
 908   2                      
 909   2                      if ( 6 == i )
 910   2                      {
 911   3                              V_ucAddrType = F_COMMADDRTYPE_AA;
 912   3                      }
 913   2              }
 914   1              
 915   1              return ( V_ucAddrType ); 
 916   1      }
 917          ///**********************************************************************///
 918          ///* Brief:  é€šä¿¡å†™emuå¯„å­˜å™¨åœ°å€ï¼ˆæ ¡è¡¨ï¼‰                                 *///
 919          ///*                                                                    *///
 920          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
 921          ///*                                                                    *///
 922          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                *///
 923          ///*                                                                    *///
 924          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
 925          ///**********************************************************************///
 926          ///* fe fe fe fe 68     A0 â€¦ A5 68 2F 0C DI0-DI3 PA P0-P2 C0-C3 N1-Nn CS      16  *///
 927          ///* 0  1     3  4  5     10          14      18       22                   *///
 928          static uchar8 ApiDLT645_WriteEmuReg( uchar8 v_ucChID )
 929          {
 930   1              uchar8  V_ucErrorType = API_DLT645_COMM_ERR_NOAUTH;
 931   1              
 932   1              do{
 933   2                      // Brief: æ•°æ®é•¿åº¦é”™äº†ï¼Œå›å¤æœªæˆæƒé”™è¯¯
 934   2      //              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] != 0x10 )    // æ•°æ®é•¿åº¦16å­—èŠ‚
 935   2      //              {
 936   2      //                      break;
 937   2      //              }
 938   2      //              
 939   2      //              // Brief: DI3é”™è¯¯ï¼Œå›å¤æœªæˆæƒé”™è¯¯
 940   2      //              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3] != 0x80 )
 941   2      //              {
 942   2      //                      break;
 943   2      //              }
 944   2                      
 945   2      //              // Brief: ä¸åœ¨å‚å†…ï¼Œå›å¤æœªæˆæƒé”™è¯¯
 946   2                      if ( (GStr_Flag.ucMeterMode&F_FACTORY_MODE) != F_FACTORY_MODE )  
 947   2                      {
 948   3                              break;
 949   3                      }
 950   2                      
 951   2      //              // Brief: å¯†ç ä¸æ˜¯00çº§ï¼Œå›å¤æœªæˆæƒé”™è¯¯
 952   2      //              if ( 0x00 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0] )
 953   2      //              {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 18  

 954   2      //                      break;
 955   2      //              }
 956   2                      // Brief: å¯†ç ä¸å¯¹ï¼Œå›å¤æœªæˆæƒé”™è¯¯
 957   2      //              if ( _TRUE != LibPub_CheckPassword( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0]) )   
 958   2      //              {
 959   2      //                      break;                  
 960   2      //              }
 961   2                      
 962   2                      // Brief: ä»¥ä¸Šéƒ½å¯¹ï¼Œåˆ™å¼€å§‹æ“ä½œ
 963   2                      if( _SUCCESS == ApiMS_CalibrationMeterComm(v_ucChID) )
 964   2                      {
 965   3                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
 966   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
 967   3                      } 
 968   2                      
 969   2              }while(0); 
 970   1      
 971   1              
 972   1              return  V_ucErrorType;
 973   1      }
 974          ///*--------------------------------- æ³¨é‡Šè¯¦è§£åŒº ----------------------------------------------------
             ------*///
 975          
 976          ///* æ³¨é‡Š1: [33 33 33 B3] æ‹¬å·å†…ä»å·¦åˆ°å³ä¸€æ¬¡ä¸ºå¯„å­˜å™¨ä½åœ°å€ã€å¯„å­˜å™¨é«˜åœ°å€ã€æ•°æ®
             -é•¿åº¦(å›ºå®š00)ã€åŠŸèƒ½ç ï¼ˆ80:è¯»æ ¡è¡¨å¯„å­˜å™¨EC,81ï¼šè¯»è®¡é‡å‚æ•°å¯„å­˜å™¨EPï¼‰*///
 977          
 978          ///* æ³¨é‡Š2: è¯¥å‘½ä»¤ä¸åˆ¤æ–­é€šä¿¡åœ°å€ç±»å‹ï¼Œä¸ºå‚å†…è°ƒè¯•å‘½ä»¤ï¼Œä¸åšè¦æ±‚ *///
 979          
 980          ///*------------------------------------------------------------------------------------------------------
             -*///
 981          ///**********************************************************************///
 982          ///* Brief:  é€šä¿¡è¯»emuå¯„å­˜å™¨åœ°å€                                         *///
 983          ///*                                                                    *///
 984          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
 985          ///*                                                                    *///
 986          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                *///
 987          ///*                                                                    *///
 988          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
 989          ///**********************************************************************///
 990          ///* FE FE FE FE 68 00 00 00 00 00 00 68 2E 04 [33 33 39 B3] cs 16   8006xxxx*///
 991          ///* FE FE FE FE 68 00 00 00 00 00 00 68 2E 04 [33 36 34 B3] cs 16   80010300 åŠŸç‡åŸå§‹å€¼*///
 992          
 993          static uchar8 ApiDLT645_ReadEmuReg( uchar8 v_ucChID )
 994          {
 995   1              uchar8  V_ucErrorType = API_DLT645_COMM_ERR_NODATA; 
 996   1      
 997   1              do{
 998   2                      
 999   2                      // Brief: æ•°æ®é•¿åº¦é”™äº†å°±å›å¤å…¶ä»–é”™è¯¯
1000   2                      if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] != 4 )
1001   2                      {
1002   3                              V_ucErrorType = API_DLT645_COMM_ERR_OTHER ; 
1003   3                              break;
1004   3                      }
1005   2                      
1006   2                      // Brief:  DI3å¿…é¡»ä¸º80H
1007   2                      if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3] != 0x80 )
1008   2                      {
1009   3                              V_ucErrorType = API_DLT645_COMM_ERR_OTHER ; 
1010   3                              break;
1011   3                      }
1012   2                      
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 19  

1013   2                      // Brief: åˆ¤æ–­ä¸€ä¸‹DI2æ˜¯å¦ä¸ºè¯»è®¡é‡èŠ¯ç‰‡å¯„å­˜å™¨
1014   2                      if( ( 0x03 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2] ) &&
1015   2                              ( 0x04 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2] )&&
1016   2                              ( 0x01 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2] )
1017   2                        )
1018   2                      { 
1019   3                              V_ucErrorType = API_DLT645_COMM_ERR_OTHER ; 
1020   3                              break;
1021   3                      }
1022   2                      
1023   2                      if( _SUCCESS == ApiMS_CalibrationMeterComm( v_ucChID ) )
1024   2                      {
1025   3                              V_ucErrorType = API_DLT645_COMM_ERR_OK; 
1026   3                              if( (0x01 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2])||
1027   3                                      ((0x01 == Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2])&&(0xFF != Gstr_UartComm[v_ucChID].u
             -caCommTXBuff[API_DLT645_DI0]))
1028   3                                )
1029   3                              {
1030   4                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 8;
1031   4                              }               
1032   3                              else if( (0x03==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+1])||
1033   3                                      (0x05==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+1])||
1034   3                                      (0x07==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+1])
1035   3                                      )
1036   3                              {
1037   4                                      
1038   4                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 20;  ///æ•°æ®æ ‡è¯†+ABCåˆç›¸æ•°æ®
1039   4                                      
1040   4                              }
1041   3                              else
1042   3                              {
1043   4                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 16;  ///æ ¡è¡¨å‚æ•°æ²¡æœ‰åˆç›¸æ•°æ®
1044   4                              }
1045   3                      } 
1046   2              }while(0);
1047   1              
1048   1              return V_ucErrorType;
1049   1      }
1050          ///**********************************************************************///
1051          ///* Brief:  07è§„çº¦è¯»æ•°æ®                                                *///
1052          ///*                                                                    *///
1053          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
1054          ///*                                                                    *///
1055          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
1056          ///*                                                                    *///
1057          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
1058          ///**********************************************************************///
1059          static uchar8 ApiDLT645_ReadData07( uchar8 v_ucChID )
1060          {
1061   1              uchar8          *P_ucTemp,V_ucErrorType;
1062   1              uchar8      V_ucTable[5];
1063   1              ulong32         V_ulDI3DI2DI1DI0;
1064   1              uchar8    V_Temp,i,V_Temp1,V_LcdNum;
1065   1              uchar8    V_ucPassword[11];
1066   1              uchar8    V_ucTempData[60];
1067   1              ushort16  V_usStateFlag3;
1068   1              
1069   1              V_ulDI3DI2DI1DI0  = (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0];
1070   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+1]<<8;
1071   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2]<<16;
1072   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3]<<24;
1073   1      
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 20  

1074   1              /* è“ç‰™çš„å¿ƒè·³åŒ… */
1075   1              if( (0xEEEE0100 == V_ulDI3DI2DI1DI0)            /* è‡ªæ‰©å‘½ä»¤ */
1076   1                      && (0x04 == Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] ))    
1077   1              {
1078   2                      GStr_Monitor.ucBleConnectCnt = 0;       /* è¿æ¥è®¡æ—¶å™¨æ¸…é›¶ */
1079   2                      return (API_DLT645_COMM_ERR_NOACK);
1080   2              }
1081   1      
1082   1              if( 0x04040300 == V_ulDI3DI2DI1DI0 )    ///* æ¶²æ™¶æŸ¥çœ‹ *///
1083   1              {
1084   2                      if(     0x09 == Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
1085   2                      {
1086   3                              V_ulDI3DI2DI1DI0  = (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R];
1087   3                              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+1]<<8;
1088   3                              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+2]<<16;
1089   3                              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+3]<<24;
1090   3                              
1091   3                              // æŸ¥çœ‹è¡¨å·ã€é€šä¿¡åœ°å€å’Œå®¢æˆ·ç¼–å·æ—¶ï¼Œè¦åˆ¤æ–­ä¸€ä¸‹å±æ•°æ˜¯å¦è¶…å‡ºå…è®¸å€¼ã€0ï¼Œ1ã€
             -‘
1092   3                              //-----------------------------------------------------------------------------------------------
1093   3                              if((0x04000401==V_ulDI3DI2DI1DI0)||(0x04000402==V_ulDI3DI2DI1DI0)||(0x0400040E==V_ulDI3DI2DI1DI0))
1094   3                              {
1095   4                                      if(1<Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+4])
1096   4                                      {
1097   5                                       return(API_DLT645_COMM_ERR_NODATA);
1098   5                                      }
1099   4                              }
1100   3                              else if( 0xFFFFFFFF==V_ulDI3DI2DI1DI0)///*å…¨æ˜¾å±æ•°è¦ä¸º0xFF
1101   3                              {
1102   4                                      if(0xFF!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+4])
1103   4                                      {
1104   5                                               return(API_DLT645_COMM_ERR_NODATA);
1105   5                                      }
1106   4                              }
1107   3                              else
1108   3                              {
1109   4                                      if(0x00!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+4])
1110   4                                      {
1111   5                                               return(API_DLT645_COMM_ERR_NODATA);
1112   5                                      }
1113   4                              }
1114   3                              V_Temp=ApiGet_Lcd_Num(V_ulDI3DI2DI1DI0,Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+4]);
1115   3                              if(0x00!=V_Temp)
1116   3                              {
1117   4                                      V_Temp-=1;
1118   4                                      GStr_DisplayPara.ucDispNum=V_Temp;  ///è·å–çš„å±æ•°ä»ç¬¬1å±å¼€å§‹çš„ï¼Œå®é™…æ˜¯ä»ç¬¬0å±å¼€å§‹ï
             -¼Œéœ€å‡1
1119   4                                  GStr_Flag.ucDisp &= F_DISP_COM_DIASP;//æ¸…å…¶ä»–æ˜¾ç¤ºæ ‡å¿—
1120   4                                      GStr_Flag.ucDisp |= F_DISP_COM_DIASP;
1121   4                              }       
1122   3                              else
1123   3                              {
1124   4                                  return(API_DLT645_COMM_ERR_NODATA);
1125   4                              }
1126   3                              GStr_DisplayPara.ulDisptimer = LCD_DISP_COMM_TIME/LCD_UPTATA_TIME;    //æ¶²æ™¶æŸ¥çœ‹æ—¶é—´èµ‹å€¼//500ms
             -å‡1
1127   3                              GStr_DisplayPara.ucBackLightTime=LCD_DISP_COMM_TIME/LCD_UPTATA_TIME/2;//èƒŒå…‰1Så‡1ï¼Œæ‰€ä»¥æ—¶é—´è¦ä
             -¸ºæ˜¾ç¤ºçš„ä¸€åŠ
1128   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=9;
1129   3                              return(API_DLT645_COMM_RD_OK);
1130   3                      }
1131   2                      else
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 21  

1132   2                      {
1133   3                              return(API_DLT645_COMM_ERR_OTHER);
1134   3                      }
1135   2              }
1136   1              
1137   1              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] != 0x04 )    ///* æ•°æ®é•¿åº¦ä¸å¯¹ *///
1138   1              {
1139   2                              return(API_DLT645_COMM_ERR_OTHER);
1140   2              }
1141   1              if(0x04000409==V_ulDI3DI2DI1DI0)////ç”µè¡¨æœ‰åŠŸå¸¸æ•°
1142   1              {
1143   2                      
1144   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+1]=LibPub_1Hex_2_1BCD(GStr_FunConfigPara.ucFunMete
             -rConst);
1145   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R]=0;
1146   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+2]=0;
1147   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 7;
1148   2                      return (API_DLT645_COMM_ERR_OK);
1149   2                      
1150   2              }
1151   1              if(0x040501FF==V_ulDI3DI2DI1DI0)///è´¹ç‡ç”µä»·4*4
1152   1              {
1153   2                        for(i=0;i<4;i++)
1154   2                        {
1155   3                                              LibPub_MemExchangeBytes(GStr_PRICE.ucaPrice,&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+4*
             -i],4);
1156   3                              }///å››ä¸ªè´¹ç‡ç”µä»·å…¨è¿”å›å½“å‰ç”µä»·
1157   2                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 20;
1158   2                              return (API_DLT645_COMM_ERR_OK);
1159   2              }
1160   1              if(0x04000503==V_ulDI3DI2DI1DI0)  ///è¯»çŠ¶æ€å­—3
1161   1              {
1162   2                              V_usStateFlag3=ApiDLT645_GetStatusFlag3();
1163   2                        Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R]=(uchar8)V_usStateFlag3;
1164   2                        Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+1]=(uchar8)(V_usStateFlag3>>8);
1165   2                        Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=6;
1166   2                        return(API_DLT645_COMM_ERR_OK);
1167   2              }
1168   1              
1169   1              if(0x080100FF== V_ulDI3DI2DI1DI0)       /*è‡ªæ‰©æ•°æ®æ ‡è¯† 080100FF  è¯»å–ä¸Šä¸€æ¬¡è´­ç”µä¿¡æ¯ã€è¡¨å†…å‰©ä
             -½™é‡‘é¢ã€å®¢æˆ·ç¼–å·ã€è¡¨å·ã€å½“å‰æ€»ç”µé‡ã€éšæœºæ•°2ã€çŠ¶æ€å­—3ã€è¡¨å†…é€æ”¯é‡‘é¢ã€åˆé—¸å…è®¸é‡‘é¢ã€
             -å›¤ç§¯é‡‘é¢é™å€¼*/
1170   1              {                                                                                                                       /*0~17                                  18~21           22~27   28~33   34~37      38~41     42        44~47         48~51       
             - 52~55*/
1171   2                      /*ä¸Šä¸€æ¬¡è´­ç”µè®°å½•*/
1172   2                      V_Temp = GStr_EventValidPiont.uc_Point[C_BuyMoney];             /*ä¸Šä¸€æ¬¡è´­ç”µè®°å½•çš„æŒ‡é’ˆ*/
1173   2                      V_Temp1 = CAddr_SelfMoney_Lenth;                /*ä¸Šä¸€æ¬¡è´­ç”µè®°å½•çš„é•¿åº¦*/
1174   2                      Hal_ReadEEPROM( V_ucTempData,CAddr_SelfMoney_Note+V_Temp*V_Temp1,V_Temp1 );             /*è¯»å–è´­ç”µè®°å½•*/
1175   2                      LibPub_Inverse( &V_ucTempData[0], 2 );          /*ä¸Šä¸€æ¬¡è´­ç”µåè´­ç”µæ€»æ¬¡æ•°*/
1176   2                      LibPub_Inverse( &V_ucTempData[2], 4 );          /*ä¸Šä¸€æ¬¡è´­ç”µé‡‘é¢*/
1177   2                      LibPub_Inverse( &V_ucTempData[6], 4 );          /*ä¸Šä¸€æ¬¡è´­ç”µå‰å‰©ä½™é‡‘é¢*/
1178   2                      LibPub_Inverse( &V_ucTempData[10], 4 );         /*ä¸Šä¸€æ¬¡è´­ç”µåå‰©ä½™é‡‘é¢*/
1179   2                      LibPub_Inverse( &V_ucTempData[14], 4 );         /*ä¸Šä¸€æ¬¡è´­ç”µåæ€»è´­ç”µé‡‘é¢*/
1180   2                        
1181   2                      /*è¡¨å†…å‰©ä½™é‡‘é¢*/
1182   2                      LibPub_MemExchangeBytes( &GStr_Money.ucaRemainMoney[0], &V_ucTempData[18], 0x04 );      
1183   2                      
1184   2                      /*è¡¨å†…é€æ”¯é‡‘é¢*/
1185   2                      LibPub_MemExchangeBytes( GStr_Money.ucaTickMoney, &V_ucTempData[22], 0x04 );    
1186   2                              
1187   2                      /*åˆé—¸å…è®¸é‡‘é¢*/
1188   2                      LibPub_MemExchangeBytes( GStr_MoneyPara.ucaAllowcloseMoney, &V_ucTempData[26], 0x04 );  
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 22  

1189   2                              
1190   2                      /*å›¤ç§¯é‡‘é¢é™å€¼*/
1191   2                      LibPub_MemExchangeBytes( GStr_MoneyPara.ucaMaxMoneyLimit, &V_ucTempData[30], 0x04 );    
1192   2                              
1193   2                      /*å½“å‰æ€»ç”µé‡*/
1194   2                      LibPub_MemExchangeBytes( &GStr_Energy.ucaFw_Energy[0], &V_ucTempData[34], 0x04 );
1195   2                              
1196   2                      /*å®¢æˆ·ç¼–å·*/
1197   2                      LibPub_MemExchangeBytes( &GStr_MeterIFO.ucaUserID[0], &V_ucTempData[38], 0x06 );        
1198   2                      
1199   2                      /*è¡¨å·*/
1200   2                      LibPub_MemExchangeBytes( &GStr_MeterIFO.ucaMeterID[0], &V_ucTempData[44], 0x06 );
1201   2                      
1202   2                      /*éšæœºæ•°2*/
1203   2                      if( 0==(GStr_Flag.ucRunState2 & F_RUN_INTAUTHAvailabilityFlag) )                /*èº«ä»½è®¤è¯å¤±æ•ˆé‡æ–°è·å–éšæœº
             -æ•°*/
1204   2                      {
1205   3                              PrepaymentModule_GetChallenge(&GStr_VirtualEsamPara.ucRs485RandNum2[0], 0x04) ;         /*è·å–éšæœºæ•°2*/
1206   3                              LibPub_MemSetBytes(&GStr_VirtualEsamPara.ucRs485RandNum2[4], 0x00, 4);
1207   3                      }               /*èº«ä»½è®¤è¯æœ‰æ•ˆç›´æ¥æŠŠå½“å‰çš„éšæœºæ•°2è¿”å›*/                        
1208   2                      LibPub_MemExchangeBytes(&GStr_VirtualEsamPara.ucRs485RandNum2[0], &V_ucTempData[50], 0x04 );            /*æ•°æ®å€
             -’å‘ä»¥ä¾¿æ•°æ®è¿”å›*/              
1209   2                        
1210   2                      /*çŠ¶æ€å­—3*/
1211   2                      V_usStateFlag3 = ApiDLT645_GetStatusFlag3();
1212   2                      V_ucTempData[54] = (uchar8)V_usStateFlag3;
1213   2                      V_ucTempData[55] = (uchar8)(V_usStateFlag3>>8);
1214   2                      // if(GStr_Flag.ucRunState2&F_RUN_OpenAccoutFlag)///å¼€æˆ·çŠ¶æ€
1215   2                      // {
1216   2                      //              V_ucTempData[42]=0x00;
1217   2                      // }
1218   2                      // else
1219   2                      // {
1220   2                      //              V_ucTempData[42]=0x01;
1221   2                      // }GStr_Money. ucaTickMoney
1222   2                      GStr_Flag.ucRunState3|=F_RUN_READ_RANDOM2;              /*ç½®è¯»å–éšæœºæ•°æ ‡å¿—*/
1223   2                      GStr_Monitor.ulReadRandom2DelayTime=LibPub_GetTimerBeat();              /*è¯»éšæœºæ•°2åå–ç³»ç»Ÿæ—¶é—´*/
1224   2                      /*ç½®äº”åˆ†é’Ÿ*/ 
1225   2                      LibPub_MemCopyBytes( V_ucTempData, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], 56);        
1226   2                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=60;
1227   2                      return (API_DLT645_COMM_ERR_OK);                        
1228   2              }
1229   1              
1230   1              if((0x03==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3])
1231   1              ||(0x1D==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3])
1232   1              ||(0x1E==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3]))///äº‹ä»¶è®°å½•
1233   1              {
1234   2                      V_ucErrorType = ReadEventRecordData(V_ulDI3DI2DI1DI0,&(Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_
             -D0_R]), &(Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]));
1235   2              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]+=4;///é•¿åº¦åŠ 4å­—èŠ‚æ•°æ®æ ‡è¯†
1236   2                      return  V_ucErrorType;
1237   2              }
1238   1              
1239   1              if(0x04000C00==(V_ulDI3DI2DI1DI0&0xFFFFFFF0)) ///å¯†ç ç›´æ¥ä»EEè¯»
1240   1          {
1241   2                      if((GStr_Flag.ucMeterMode&F_FACTORY_MODE)!=F_FACTORY_MODE)///*å‚å¤–å¯†ç ä¸å¯è¯»
1242   2                      {return (API_DLT645_COMM_ERR_NOACK);}
1243   2                      else
1244   2                      {
1245   3                              LibPub_ReadDataFromE2prom(LIB_E2P_Password, 0, V_ucPassword);
1246   3                              LibPub_MemCopyBytes(&V_ucPassword[(Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0]-1)*3],&Gstr_Ua
             -rtComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R+1],3);
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 23  

1247   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R]=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645
             -_DI0]-1;
1248   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=8;
1249   3                              return (API_DLT645_COMM_ERR_OK);        
1250   3                      }
1251   2                      
1252   2              }
1253   1              
1254   1              if((0x04040100==(V_ulDI3DI2DI1DI0&0xFFFFFF00))||(0x04040200==(V_ulDI3DI2DI1DI0&0xFFFFFF00)))///*å¾ªæ˜¾é¡¹
             -å’Œé”®æ˜¾é¡¹
1255   1              {
1256   2                              V_Temp=V_ulDI3DI2DI1DI0&0x000000FF;
1257   2                              if(30<V_Temp)///æœ€å¤§ä¸º30å±
1258   2                              {
1259   3                                      return (API_DLT645_COMM_ERR_NODATA) ;
1260   3                              }
1261   2                              if(     0x04040100==(V_ulDI3DI2DI1DI0&0xFFFFFF00))//å¾ªæ˜¾
1262   2                              {
1263   3                                              for(i=0;i<MAX_Comm_MAP_TAB;i++)
1264   3                                              {
1265   4                                                              if(0x04040101==Comm_MAP_TAB[i].ucaDataId)
1266   4                                                              {
1267   5                                                                              V_Temp1=i;
1268   5                                                                              break;
1269   5                                                              }
1270   4                                              }
1271   3                              }
1272   2                              else                   //é”®æ˜¾
1273   2                              {
1274   3                                              for(i=0;i<MAX_Comm_MAP_TAB;i++)
1275   3                                              {
1276   4                                                              if(0x04040201==Comm_MAP_TAB[i].ucaDataId)
1277   4                                                              {
1278   5                                                                      V_Temp1=i;
1279   5                                                                      break;
1280   5                                                              }
1281   4                                              }
1282   3                              }
1283   2                              V_LcdNum = Comm_MAP_TAB[V_Temp1].ucaRamAdd[V_Temp-1];
1284   2                              V_ulDI3DI2DI1DI0=ApiGet_Lcd_ID(V_LcdNum);
1285   2                              V_ucTable[1]=(uchar8)((V_ulDI3DI2DI1DI0>>24)&0x000000FF);
1286   2                              V_ucTable[2]=(uchar8)((V_ulDI3DI2DI1DI0>>16)&0x000000FF);
1287   2                              V_ucTable[3]=(uchar8)((V_ulDI3DI2DI1DI0>>8)&0x000000FF);
1288   2                              V_ucTable[4]=(uchar8)((V_ulDI3DI2DI1DI0)&0x000000FF);
1289   2                              if((4==V_LcdNum)||(6==V_LcdNum)||(8==V_LcdNum))///è¡¨å·é€šä¿¡åœ°å€å®¢æˆ·ç¼–å·
1290   2                              {
1291   3                                      V_ucTable[0]=0x01;
1292   3                              }
1293   2                              else
1294   2                              {
1295   3                                      V_ucTable[0]=0x00;
1296   3                              }
1297   2                              
1298   2                              LibPub_MemExchangeBytes( V_ucTable, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R],5); ///*è¿”
             -å›æ•°æ®ä¸ºæ•°æ®æ ‡è¯†åŠ å±å· 5å­—èŠ‚
1299   2                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 5+4;  ///è¿”å›æ•°æ®é•¿åº¦ä¸ºæ•°æ®é•¿åº¦åŠ ä¸
             -Š4
1300   2                              return (API_DLT645_COMM_ERR_OK);
1301   2              }
1302   1          for(i=0;i<MAX_Comm_MAP_TAB;i++)
1303   1              {
1304   2                      if(V_ulDI3DI2DI1DI0==Comm_MAP_TAB[i].ucaDataId)
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 24  

1305   2                      {
1306   3                              
1307   3                              P_ucTemp = Comm_MAP_TAB[i].ucaRamAdd;
1308   3                              LibPub_MemExchangeBytes( P_ucTemp, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], Comm_MAP_TA
             -B[i]. ucaDataLen);    
1309   3                              if((_TRUE==Comm_MAP_TAB[i].IsBCD)&&(_TRUE==Comm_MAP_TAB[i].EEIsHEX))///ç›®å‰åªæœ‰æ˜¾ç¤ºå‚æ•°éœ€è¦è½
             -¬æ¢æ ¼å¼
1310   3                              {
1311   4                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R]=LibPub_1Hex_2_1BCD(Gstr_UartComm[v_ucChID].ucaC
             -ommTXBuff[API_DLT645_D0_R]);
1312   4                              }
1313   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = Comm_MAP_TAB[i]. ucaDataLen+4;  ///è¿”å›æ•°æ®
             -é•¿åº¦ä¸ºæ•°æ®é•¿åº¦åŠ ä¸Š4
1314   3                              return (API_DLT645_COMM_ERR_OK);
1315   3                      }       
1316   2              }
1317   1              return (API_DLT645_COMM_ERR_NODATA) ;
1318   1      }
1319          
1320          ///**********************************************************************///
1321          ///* Brief: å†™æ•°æ®                                                      *///
1322          ///*                                                                    *///
1323          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
1324          ///*                                                                    *///
1325          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
1326          ///*                                                                    *///
1327          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
1328          ///**********************************************************************///
1329          ///* FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 C  L  DI0DI1DI2DI3 PAP0P1P2 C0C1C2C3 D0D1...Dn CS 16 *///
1330          static uchar8 ApiDLT645_WriteData( uchar8 v_ucChID)
1331          {
1332   1              uchar8          V_ucErrorType = API_DLT645_COMM_ERR_NOAUTH;     ///* å¯†ç é”™æœªæˆæƒ *///
1333   1              uchar8          P_ucTemp[64];
1334   1              uchar8      V_Temp,V_Temp1,V_ScreenNum,V_LcdNum,i;
1335   1              ulong32         V_ulDI3DI2DI1DI0;
1336   1              //uchar8        V_ucBleStatus;
1337   1      
1338   1              V_ulDI3DI2DI1DI0  = (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0];
1339   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+1]<<8;
1340   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2]<<16;
1341   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3]<<24;
1342   1              
1343   1              if((V_ulDI3DI2DI1DI0 & 0xFFFFFF00) == 0xEEEEEE00)
1344   1              {
1345   2                      //V_ucBleStatus = BleDrv_GetBleStat();
1346   2                      if( BLE_STAT_CONNECTED != GStr_Flag.ucBLESTATFlag)              ///*ç©ºé—²çŠ¶æ€*///
1347   2                      {
1348   3                              V_Temp = API_DLT645_COMM_ERR_NOACK;     ///*ç©ºé—²çŠ¶æ€ä¸åº”ç­”*///
1349   3                              return(V_Temp);
1350   3                      }
1351   2                      else
1352   2                      {
1353   3                              V_Temp = MultiDataWrite_Deal(v_ucChID);
1354   3                              return (V_Temp);        
1355   3                      }
1356   2              }
1357   1      
1358   1              switch(Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0] )
1359   1              {
1360   2                      case 0x98:
1361   2                      case 0x99:
1362   2                      {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 25  

1363   3                              if((0==(GStr_Flag.ucRunState2&F_RUN_INTAUTHAvailabilityFlag))||(GStr_Flag.ucRunState2&F_RUN_INTAUTH_MAC
             -NumErrFlag))
1364   3                              {
1365   4                                      return(API_DLT645_COMM_ERR_NOAUTH);
1366   4                              }///98\99çº§å¯†ç èº«ä»½è®¤è¯å¤±æ•ˆå’Œèº«ä»½è®¤è¯æŒ‚èµ·ï¼Œ å›å¯†ç é”™
1367   3                              V_Temp1=0;
1368   3                              switch(V_ulDI3DI2DI1DI0)
1369   3                              {
1370   4                                              case 0x04000402:        //è¡¨å·
1371   4                                              case 0x0400040E:        //å®¢æˆ·ç¼–å·
1372   4                                              case 0x04001001:        //æŠ¥è­¦é‡‘é¢1
1373   4                                              case 0x04001002:        //æŠ¥è­¦é‡‘é¢2
1374   4                                              #if(METER_TYPE==METER_TYPE_DTSY666)  ///å•ç›¸è¡¨ä¸å¯å†™ç”µå‹ç”µæµäº’æ„Ÿå™¨å˜æ¯”ï¼Œé»˜è®¤ä¸º1
                                                      case 0x04000306:  //ç”µå‹äº’æ„Ÿå™¨å˜æ¯”
                                                      case 0x04000307:  //ç”µæµäº’æ„Ÿå™¨å˜æ¯”
                                                      #endif
1378   4                                              {
1379   5                                                      V_Temp1 = 11;
1380   5                                              }break;
1381   4                                              
1382   4                                              case 0x040501FF:        ///* å½“å‰å¥—è´¹ç‡ç”µä»·4*4 *///
1383   4                                              {
1384   5                                                      V_Temp1 = 12;
1385   5                                              }break;
1386   4                                              default:break;
1387   4                              }
1388   3                              if(V_Temp1!=0)
1389   3                              {
1390   4                                      V_Temp=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]-16;
1391   4                                      if( (0x99==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0]) && (_SUCCESS==LibPub_IsBCD(&Gstr_Uar
             -tComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W], V_Temp )))
1392   4                                      {
1393   5                                              if(V_Temp1==12)
1394   5                                              {
1395   6                                                                      for( i = 0; i < 4; i++ )
1396   6                                                                      {
1397   7                                                                              LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+i*4],  4);        ///*æ•°æ®å€’å‘
             - *///
1398   7                                                                              
1399   7                                                                      }
1400   6                                              }
1401   5                                              else
1402   5                                              {
1403   6                                                              LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],  V_Temp);       ///*æ•°æ®å€’åº 
             -*///
1404   6                                              }
1405   5                                              LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+V_Temp], 4); ///* MACå€’åº*///
1406   5                                              if( C_ERR == PrepaymentModule_CommWriteESAMBinaryMAC(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT64
             -5_D0_W], V_Temp, V_Temp1, 0x01) )
1407   5                                              { return(API_DLT645_COMM_ERR_NOAUTH); }
1408   5                                              if(V_Temp1==12)
1409   5                                              {
1410   6                                                                      for( i = 0; i < 4; i++ )
1411   6                                                                      {
1412   7                                                                                      LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+i*4],  4);        ///* æ•°æ®å€’å
             -º*///
1413   7                                                                      }
1414   6                                              }
1415   5                                              else
1416   5                                              {
1417   6                                                              LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],  V_Temp);       ///* æ•°æ®å€’åº
             - *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 26  

1418   6                                              }
1419   5                                              
1420   5                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]-=4;
1421   5      
1422   5                                      }
1423   4                                      else
1424   4                                      {
1425   5                                              return(API_DLT645_COMM_ERR_NOAUTH);
1426   5                                      }
1427   4                              }
1428   3                              else if(0x98==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0])
1429   3                              {
1430   4                                  if( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]>16)
1431   4                                      {
1432   5                                                      if( ((V_ulDI3DI2DI1DI0==0x04001006) || (V_ulDI3DI2DI1DI0==0x040010FF)) && (Gstr_UartComm[v_ucChID].u
             -caCommTXBuff[API_DLT645_LEN]== 24) )
1433   5                                                      {
1434   6                                                              V_Temp1 = 15;  ///é€€è´¹
1435   6                                                      }
1436   5                                                      else
1437   5                                                      {
1438   6                                                              V_Temp1 = 16;  //äºŒç±»å‚æ•°è®¾ç½®
1439   6                                                      }
1440   5                                                      V_Temp=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]-16;
1441   5                                                      LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],  V_Temp);       ///*æ•°æ®å€’åº *
             -///
1442   5                                                      LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+V_Temp], 4); ///* MACå€’åº*//
             -/
1443   5                                                      ///*æ•°æ®è§£å¯†  å¸¦MAC *///
1444   5                                                      if( C_ERR == PrepaymentModule_DataDecription(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W]
             -, V_Temp1, &V_Temp) )
1445   5                                                      { return(API_DLT645_COMM_ERR_NOAUTH);}
1446   5                                                      
1447   5                                                      LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W], V_Temp );
1448   5                                                      if( V_Temp1 == 15 )///* é€€è´¹0x04001006 *///
1449   5                                                      {
1450   6                                                              if(( BLE_STAT_CONNECTED != GStr_Flag.ucBLESTATFlag)&&(V_ulDI3DI2DI1DI0 == 0x040010FF))          ///*ç©ºé—²ç
             -Š¶æ€*///
1451   6                                                              {
1452   7                                                                      return(API_DLT645_COMM_ERR_NOACK);              ///*ç©ºé—²çŠ¶æ€ä¸åº”ç­”*///                                                           
1453   7                                                              }
1454   6      
1455   6                                                              P_ucTemp[0] = PrepaymentModule_Comm_HandBackMoney(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645
             -_D0_W]);
1456   6                                                              if( V_ulDI3DI2DI1DI0 == 0x040010FF )    ///*è‡ªæ‰©é€€è´¹å‘½ä»¤ï¼Œå¸¦è¿”å›å‚æ•°ï¼Œä¸åŸå…ˆé€€è´¹å‘½ä
             -»¤å…¼å®¹*///
1457   6                                                              {
1458   7                                                                      ///å½“å‰æ€»ç”µé‡4å­—èŠ‚
1459   7                                                                      LibPub_MemExchangeBytes(&GStr_Energy.ucaFw_Energy[0], &P_ucTemp[1], 0x04 );
1460   7      
1461   7                                                                      ///è¡¨å†…å‰©ä½™é‡‘é¢4å­—èŠ‚
1462   7                                                                      LibPub_MemExchangeBytes(&GStr_Money.ucaRemainMoney[0], &P_ucTemp[5], 0x04 );
1463   7      
1464   7                                                                      ///è´­ç”µæ¬¡æ•°4å­—èŠ‚
1465   7                                                                      LibPub_MemExchangeBytes(&GStr_PRICE.ucPurchaseTimes[0], &P_ucTemp[9], 0x04 );
1466   7      
1467   7                                                                      ///è¡¨å†…é€æ”¯é‡‘é¢4å­—èŠ‚
1468   7                                                                      LibPub_MemExchangeBytes(GStr_Money.ucaTickMoney, &P_ucTemp[13], 0x04 );
1469   7      
1470   7                                                                      ///çŠ¶æ€å­—3 2å­—èŠ‚
1471   7                                                                      //V_usStateFlag3=ApiDLT645_GetStatusFlag3();
1472   7                                                                      P_ucTemp[17]=(uchar8)ApiDLT645_GetStatusFlag3();
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 27  

1473   7                                                                      P_ucTemp[18]=(uchar8)(ApiDLT645_GetStatusFlag3()>>8);
1474   7      
1475   7                                                                      LibPub_MemCopyBytes( P_ucTemp, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], 19);    
1476   7      
1477   7                                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 23;///*è¿”å›æ•°æ®çš„é•¿åº¦ï¼ŒåŒ…å«äº†4ä
             -¸ªå­—èŠ‚çš„æ ‡è¯†ç *///                                                      
1478   7                                                              }
1479   6                                                              return( P_ucTemp[0] );
1480   6                                                      }
1481   5                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 12+V_Temp;
1482   5                                      }
1483   4                                      else
1484   4                                      {
1485   5                                              return(API_DLT645_COMM_ERR_NOAUTH);
1486   5                                      }
1487   4                              }
1488   3                              else
1489   3                              {
1490   4                                      return(API_DLT645_COMM_ERR_NOAUTH);
1491   4                              }       
1492   3                      }break;
1493   2                      case 0x00:    ///00çº§å¯†ç åªèƒ½ä¿®æ”¹01çº§ã€02çº§å¯†ç 
1494   2                      {
1495   3                              if((V_ulDI3DI2DI1DI0!=0x04000C01)&&(V_ulDI3DI2DI1DI0!=0x04000C02)&&(V_ulDI3DI2DI1DI0!=0x04000C03))
1496   3                              {
1497   4                                      return(API_DLT645_COMM_ERR_NOAUTH);
1498   4                              }
1499   3                              if((_FAILED==LibPub_CheckPassword(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0]))&&(!(GStr_Fla
             -g.ucMeterMode&F_FACTORY_MODE)))
1500   3                              {////å¯†ç é”™è¯¯ å¹¶ä¸”å‚å¤–æ¨¡å¼   å‚å†…æ¨¡å¼ä¸åˆ¤æ–­å¯†ç ï¼Œåªåˆ¤å¯†çº§
1501   4                                      return(API_DLT645_COMM_ERR_NOAUTH);
1502   4                              }
1503   3                      }break;
1504   2                      case 0x01:  ///01çº§å¯†ç ä¸èƒ½ä¿®æ”¹00çº§å¯†ç   
1505   2                      {
1506   3                              if(V_ulDI3DI2DI1DI0==0x04000C01)
1507   3                              {
1508   4                                      return(API_DLT645_COMM_ERR_NOAUTH);
1509   4                              }
1510   3                              if(!(GStr_Flag.ucMeterMode&F_FACTORY_MODE))///å‚å¤–æ¨¡å¼
1511   3                              {
1512   4                                              if((V_ulDI3DI2DI1DI0==0x040501FF)||(V_ulDI3DI2DI1DI0==0x04000402)||(V_ulDI3DI2DI1DI0==0x0400040E)||(V
             -_ulDI3DI2DI1DI0==0x04001001)
1513   4                                              ||(V_ulDI3DI2DI1DI0==0x04001002)||(V_ulDI3DI2DI1DI0==0x04000306)||(V_ulDI3DI2DI1DI0==0x04000307)
1514   4                                              ||(_FAILED==LibPub_CheckPassword(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0])))
1515   4                                              {///å¯†ç é”™æˆ–ç”µä»·è¡¨å·ç­‰ä¸€ç±»å‚æ•°å›å¯†ç é”™æœªæˆæƒ
1516   5                                                              return(API_DLT645_COMM_ERR_NOAUTH);
1517   5                                              }
1518   4                                              
1519   4                              }
1520   3                              else
1521   3                              {
1522   4                                              #if(METER_TYPE!=METER_TYPE_DTSY666)  ///å•ç›¸è¡¨ä¸å¯å†™ç”µå‹ç”µæµäº’æ„Ÿå™¨å˜æ¯”ï¼Œé»˜è®¤ä¸º1
1523   4                                              if((V_ulDI3DI2DI1DI0==0x04000306)||(V_ulDI3DI2DI1DI0==0x04000307))  //å˜æ¯”
1524   4                                              {
1525   5                                                                      return(API_DLT645_COMM_ERR_NOAUTH);
1526   5                                              }
1527   4                                              #endif
1528   4                              }
1529   3                      }break;
1530   2                      case 0x02: ///02çº§å¯†ç åªèƒ½è·³å’Œé—¸ï¼Œè¯¥å‡½æ•°ä¸­åªèƒ½ä¿®æ”¹02çº§å¯†ç 
1531   2                      {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 28  

1532   3                              if(V_ulDI3DI2DI1DI0!=0x04000C03)
1533   3                              {
1534   4                                      return(API_DLT645_COMM_ERR_NOAUTH);
1535   4                              }
1536   3                              if((_FAILED==LibPub_CheckPassword(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0]))&&(!(GStr_Fla
             -g.ucMeterMode&F_FACTORY_MODE)))
1537   3                              {////å¯†ç é”™è¯¯ å¹¶ä¸”å‚å¤–æ¨¡å¼   å‚å†…æ¨¡å¼ä¸åˆ¤æ–­å¯†ç ï¼Œåªåˆ¤å¯†çº§
1538   4                                      return(API_DLT645_COMM_ERR_NOAUTH);
1539   4                              }
1540   3                      }break;
1541   2                      default:
1542   2                      return(API_DLT645_COMM_ERR_NOAUTH);
1543   2                      
1544   2              }
1545   1        if(V_ulDI3DI2DI1DI0==0x040501FF)///è´¹ç‡ç”µä»·4*4
1546   1              {
1547   2                                      if(28!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
1548   2                                                      //4å­—èŠ‚æ•°æ®æ ‡è¯†+4å­—èŠ‚å¯†ç +4å­—èŠ‚æ“ä½œè€…ä»£ç +16æ•°æ®
1549   2                                      {
1550   3                                              return ( API_DLT645_COMM_ERR_OTHER );
1551   3                                      }
1552   2                                      if(_FAILED==LibPub_IsBCD(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W], 16 ))
1553   2                                      {
1554   3                                                      return ( API_DLT645_COMM_ERR_OTHER );
1555   3                                      }
1556   2                                      LibPub_MemExchangeBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],GStr_PRICE.ucaPrice ,
             - 4);
1557   2                                              ///æ›´æ–°RAM
1558   2                                      LibPub_ReadDataFromE2prom(LIB_E2P_Price,0,P_ucTemp);//å°†EEå†…æ•°æ®è¯»å‡ºç®—CRC
1559   2                                      LibPub_MemExchangeBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],&P_ucTemp[0] , 4);
1560   2                                      LibPub_WriteDataToE2prom(LIB_E2P_Price,0,P_ucTemp );//å†™å…¥EE
1561   2                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
1562   2                                      return (API_DLT645_COMM_ERR_OK);
1563   2              }
1564   1              
1565   1              if((0x04040100==(V_ulDI3DI2DI1DI0&0xFFFFFF00))||(0x04040200==(V_ulDI3DI2DI1DI0&0xFFFFFF00)))///*å¾ªæ˜¾é¡¹
             -å’Œé”®æ˜¾é¡¹
1566   1              {
1567   2                      V_Temp=V_ulDI3DI2DI1DI0&0x000000FF;
1568   2                      if(17 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]) ///é•¿åº¦ä¸º4å­—èŠ‚æ•°æ®æ ‡è¯†+4å­—èŠ‚å
             -¯†ç +4å­—èŠ‚æ“ä½œè€…ä»£ç +5å­—èŠ‚æ•°æ®
1569   2                      {
1570   3                              return ( API_DLT645_COMM_ERR_OTHER );
1571   3                      }       
1572   2                      if(30<V_Temp)///æœ€å¤§ä¸º30å±
1573   2                      {
1574   3                              return ( API_DLT645_COMM_ERR_NODATA );
1575   3                      }
1576   2                      if(     0x04040100==(V_ulDI3DI2DI1DI0&0xFFFFFF00))//å¾ªæ˜¾
1577   2                      {
1578   3                                      for(i=0;i<MAX_Comm_MAP_TAB;i++)
1579   3                                      {
1580   4                                                      if(0x04040101==Comm_MAP_TAB[i].ucaDataId)
1581   4                                                      {
1582   5                                                                      V_Temp1=i;
1583   5                                                                      break;
1584   5                                                      }
1585   4                                      }
1586   3                      }
1587   2                      else                   //é”®æ˜¾
1588   2                      {
1589   3                                      for(i=0;i<MAX_Comm_MAP_TAB;i++)
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 29  

1590   3                                      {
1591   4                                                      if(0x04040201==Comm_MAP_TAB[i].ucaDataId)
1592   4                                                      {
1593   5                                                                      V_Temp1=i;
1594   5                                                                      break;
1595   5                                                      }
1596   4                                      }
1597   3                      }
1598   2                      V_ulDI3DI2DI1DI0  = (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W];
1599   2                      V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+1]<<8;
1600   2                      V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+2]<<16;
1601   2                      V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+3]<<24;
1602   2                      V_ScreenNum=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4];//å±å·
1603   2                      
1604   2                      V_LcdNum=ApiGet_Lcd_Num(V_ulDI3DI2DI1DI0,V_ScreenNum);
1605   2                      if(0x00!=V_LcdNum)
1606   2                      {
1607   3                              V_LcdNum-=1;///è·å–çš„å±æ•°ä»ç¬¬1å±å¼€å§‹çš„ï¼Œå®é™…æ˜¯ä»ç¬¬0å±å¼€å§‹ï¼Œéœ€å‡1
1608   3                              ///V_LcdNumä¸ºè¦å†™å…¥çš„æ˜¾ç¤ºå±å·
1609   3                              Comm_MAP_TAB[V_Temp1].ucaRamAdd[V_Temp-1]=V_LcdNum;///æ›´æ–°RAM
1610   3                              LibPub_ReadDataFromE2prom(Comm_MAP_TAB[V_Temp1].ucaE2pIndex,0,P_ucTemp);//å°†EEå†…æ•°æ®è¯»å‡ºç®—CRC
1611   3                              LibPub_MemExchangeBytes( &Comm_MAP_TAB[V_Temp1].ucaRamAdd[V_Temp-1],&P_ucTemp[Comm_MAP_TAB[V_Temp1].uca
             -E2offset+V_Temp-1]  ,  1);
1612   3                              //æ›´æ–°éœ€è¦æ›´æ”¹çš„æ•°æ®
1613   3                              LibPub_WriteDataToE2prom( Comm_MAP_TAB[V_Temp1].ucaE2pIndex, 0, P_ucTemp) ;//å°†æ›´æ–°å¥½çš„æ•°æ®å¸¦CR
             -Cå†™å…¥EE
1614   3                              
1615   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
1616   3                              return (API_DLT645_COMM_ERR_OK);
1617   3                      }
1618   2                      return ( API_DLT645_COMM_ERR_OTHER );
1619   2              }
1620   1              else
1621   1              {
1622   2                      if(0x04000300==(V_ulDI3DI2DI1DI0&0xFFFFFF00))
1623   2                      {
1624   3                              switch((uchar8)(V_ulDI3DI2DI1DI0&0x000000FF))
1625   3                              {
1626   4                                      case 0x01:   ///å¾ªç¯æ˜¾ç¤ºå±æ•°
1627   4                                      case 0x05:   ///æŒ‰é”®æ˜¾ç¤ºå±æ•°
1628   4                                      {               
1629   5                                              if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W]>0x30)||(Gstr_UartComm[v_ucChID].ucaCommTXB
             -uff[API_DLT645_D0_W]==0))
1630   5                                              {
1631   6                                                      return ( API_DLT645_COMM_ERR_OTHER );
1632   6                                              }
1633   5                                      }break;
1634   4                                      case 0x02:   ///æ¯å±æ˜¾ç¤ºæ—¶é—´
1635   4                                      case 0x08:   ///ä¸Šç”µå…¨æ˜¾æ—¶é—´
1636   4                                      {
1637   5                                              if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W]>0x30)||(Gstr_UartComm[v_ucChID].ucaCommTXB
             -uff[API_DLT645_D0_W]<0x05))
1638   5                                              {
1639   6                                                      return ( API_DLT645_COMM_ERR_OTHER );
1640   6                                              }
1641   5                                      }break;
1642   4                                      default:
1643   4                                      break;
1644   4                              }
1645   3                      }
1646   2                      for(i=0;i<MAX_Comm_MAP_TAB;i++)
1647   2                      {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 30  

1648   3                              if(V_ulDI3DI2DI1DI0==Comm_MAP_TAB[i].ucaDataId)
1649   3                              {
1650   4      
1651   4                                      if((4+4+4+Comm_MAP_TAB[i].ucaDataLen)!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
1652   4                                              //4å­—èŠ‚æ•°æ®æ ‡è¯†+4å­—èŠ‚å¯†ç +4å­—èŠ‚æ“ä½œè€…ä»£ç +æ•°æ®
1653   4                                      {
1654   5                                              return ( API_DLT645_COMM_ERR_OTHER );
1655   5                                      }
1656   4                                      if(_TRUE!=Comm_MAP_TAB[i].IsWrite)   ///ä¸æ”¯æŒå†™çš„æ•°æ®å›é”™
1657   4                                      {
1658   5                                              return ( API_DLT645_COMM_ERR_OTHER );
1659   5                                      }
1660   4                                      if(_TRUE==Comm_MAP_TAB[i].IsBCD)    ///BCDæ•°æ®å…ˆåˆ¤æ–­æ•°æ®æ˜¯å¦ä¸ºBCD
1661   4                                      {
1662   5                                              if(_FAILED==LibPub_IsBCD(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W], Comm_MAP_TAB[i].uca
             -DataLen ))
1663   5                                              {
1664   6                                                      return ( API_DLT645_COMM_ERR_OTHER );
1665   6                                              }
1666   5                                              if(_TRUE==Comm_MAP_TAB[i].EEIsHEX)
1667   5                                              {                                    ///*ç›®å‰åªæœ‰æ˜¾ç¤ºç›¸å…³å‚æ•°éœ€è¦æ›´æ¢æ ¼å¼ï¼Œå‡ä¸º1å­
             -—èŠ‚
1668   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W]=LibPub_1BCD_2_1HEX(Gstr_UartComm[v_ucChID].uc
             -aCommTXBuff[API_DLT645_D0_W]);
1669   6                                              }
1670   5                                              
1671   5                                      }
1672   4                                      if(0x04001001==V_ulDI3DI2DI1DI0)///1çº§æŠ¥è­¦
1673   4                                      {
1674   5                                              LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],P_ucTemp,4);
1675   5                                              if(C_GreaterThan!=LibPub_CompareData(P_ucTemp, GStr_MoneyPara.ucaAlarmMoneyL2, 4, CMP_MODE_HIGHT))
1676   5                                              {
1677   6                                                      return ( API_DLT645_COMM_ERR_OTHER );
1678   6                                              }
1679   5                                      }
1680   4                                      if(0x04001002==V_ulDI3DI2DI1DI0)///2çº§æŠ¥è­¦
1681   4                                      {
1682   5                                              LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],P_ucTemp,4);
1683   5                                              if(C_LessThan!=LibPub_CompareData(P_ucTemp, GStr_MoneyPara.ucaAlarmMoneyL1, 4, CMP_MODE_HIGHT))
1684   5                                              {
1685   6                                                      return ( API_DLT645_COMM_ERR_OTHER );
1686   6                                              }
1687   5                                      }///å†™1çº§æŠ¥è­¦å’Œ2çº§æŠ¥è­¦æ—¶åˆ¤æ–­ä¸‹2ä¸ªå€¼çš„å¤§å°   2çº§æŠ¥è­¦è¦æ¯”1çº§æŠ¥è­¦å°
1688   4                                      if(0x02800020==V_ulDI3DI2DI1DI0)        //ç”µä»·ä¸èƒ½é€šè¿‡æŸ¥è¡¨æ–¹å¼å†™
1689   4                                      {
1690   5                                              return ( API_DLT645_COMM_ERR_OTHER );
1691   5                                      }
1692   4                                      
1693   4                                      if(0x04000C00!=(V_ulDI3DI2DI1DI0&0xFFFFFFF0))///å¯†ç ä¸å­˜RAM
1694   4                          {
1695   5                                        if((GStr_Flag.ucRunState2&F_RUN_EsamKeyFlag)&&(0x04000402==V_ulDI3DI2DI1DI0))///æ–°å¢ï¼Œç§é’¥çŠ¶æ€
             -ä¸‹ä¸å…è®¸æ”¹è¡¨å·
1696   5                            {
1697   6                                                              return ( API_DLT645_COMM_ERR_OTHER );
1698   6                            }
1699   5                                              LibPub_MemExchangeBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],Comm_MAP_TAB[i].ucaR
             -amAdd , Comm_MAP_TAB[i].ucaDataLen);
1700   5                                              ///æ›´æ–°RAM
1701   5                                        ///RAMçš„CRCæš‚æ—¶ä¸ç®—ï¼Œæ•ˆéªŒé”™ä¹‹åç›´æ¥ä»EEæ›´æ–°
1702   5                                              LibPub_ReadDataFromE2prom(Comm_MAP_TAB[i].ucaE2pIndex,0,P_ucTemp);//å°†EEå†…æ•°æ®è¯»å‡ºç®—CRC
1703   5                                              LibPub_MemExchangeBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W],&P_ucTemp[Comm_MAP_T
             -AB[i].ucaE2offset] , Comm_MAP_TAB[i].ucaDataLen);
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 31  

1704   5                                              LibPub_WriteDataToE2prom( Comm_MAP_TAB[i].ucaE2pIndex,0,P_ucTemp );//å†™å…¥EE
1705   5                                      }
1706   4                                      else///å¯†ç 
1707   4                                      {
1708   5                                              if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0]-1)!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[A
             -PI_DLT645_D0_W])
1709   5                                              {
1710   6                                                      return ( API_DLT645_COMM_ERR_OTHER );
1711   6                                              }
1712   5                                              LibPub_ReadDataFromE2prom(Comm_MAP_TAB[i].ucaE2pIndex,0,P_ucTemp);
1713   5                                              LibPub_MemCopyBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+1],&P_ucTemp[Comm_MAP_TAB
             -[i].ucaE2offset] ,3);
1714   5                                              LibPub_WriteDataToE2prom( Comm_MAP_TAB[i].ucaE2pIndex,0,P_ucTemp );//å†™å…¥EE
1715   5                                              ///å¯†ç å€’åºå­˜å‚¨
1716   5                                              
1717   5                                      }
1718   4      
1719   4                                  if(0x04001000==(V_ulDI3DI2DI1DI0&0xFFFFFF00))///å†™æŠ¥è­¦å‚æ•°æ—¶ï¼Œéœ€é‡æ–°åˆ¤æ–­æ˜¯å¦éœ€è¦åŠ¨
             -ä½œç»§ç”µå™¨
1720   4                                      {
1721   5                                              V_Temp=(uchar8)(V_ulDI3DI2DI1DI0);
1722   5                                              if(0x02==V_Temp)///å†™äºŒçº§æŠ¥è­¦é‡‘é¢åè¦é‡æ–°åˆ¤æ–­æ˜¯å¦äºŒçº§æŠ¥è­¦
1723   5                                              {
1724   6                                                      GStr_Flag.ucRunState1 &=~F_RUN_L2_ALRAM;  //æ¸…äºŒçº§æŠ¥è­¦æ ‡å¿—ï¼Œé‡æ–°åˆ¤æ–­
1725   6                                              }
1726   5                                              ApiRelay_SubtractMoneyRelayJudge();
1727   5                                              ApiRelay_ControlProcess();
1728   5                                      }
1729   4                                      
1730   4                                      if( 0x04000401 == V_ulDI3DI2DI1DI0)             //ä¿®æ”¹åœ°å€ï¼Œéœ€è¦é‡æ–°å¹¿æ’­è“ç‰™æ¨¡å—
1731   4                                      {
1732   5                                              GStr_Flag.ucBLESTATFlag = BLE_STAT_MAC_MOD;             //éœ€è¦è®¾ç½®è“ç‰™æ¨¡å—macæ ‡å¿—
1733   5                                              /*å†™å®Œé€šä¿¡åœ°å€åéœ€è¦é‡æ–°è®¾ç½®è“ç‰™æ¨¡å—å‚æ•°ï¼Œå¹¶é‡æ–°å¹¿æ’­*/
1734   5                                              //BleDrv_BleReset();
1735   5                                              //BleDrv_InitBleRunPara();
1736   5                                              //BleDrv_SetBleStat();                                  
1737   5                                      }        
1738   4      
1739   4                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
1740   4                                      return (API_DLT645_COMM_ERR_OK);
1741   4                              }
1742   3                      }
1743   2                      return (API_DLT645_COMM_ERR_OTHER);
1744   2              }
1745   1              
1746   1      
1747   1              return (API_DLT645_COMM_ERR_OTHER);     
1748   1      }       
1749          
1750          ///**********************************************************************///
1751          ///* Brief: å¤šæ•°æ®é¡¹ç»„åˆè®¾ç½®å……å€¼å‘½ä»¤                                                     *///
1752          ///*                                                                    *///
1753          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
1754          ///*                                                                    *///
1755          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
1756          ///*                                                                    *///
1757          ///* Note:å……å€¼é‡‘é¢+è´­ç”µæ¬¡æ•°ã€ç”µä»·å‚æ•°ã€æŠ¥è­¦é‡‘é¢1ã€æŠ¥è­¦é‡‘é¢2ã€CTã€PTã€é€æ”¯é‡‘é¢
             -é™å€¼ *///
1758          ///*14 L  DI0-DI3 PA P0-P3 C0-C3 K0-K5 MAC DI1DATA BB DI2DATA BB DI3DATA BB DI4DATA BB DI5DATA BB DI6DATA 
             -BB DI7DATA*///
1759          ///*12 13 14      18 19    22    26    32  36         53         78         91         104        116     
             -   128    *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 32  

1760          ///*æ–°è“ç‰™åè®®*///
1761          ///*14 L  DI0-DI3   PA     P0-P3  C0-C3       DI1           DI1DATA*///
1762          ///*23 24 25æ•°æ®æ ‡è¯† 20å¯†çº§ 30å¯†ç  33æ“ä½œè€…ä»£ç  37ç¬¬ä¸€ä¸ªè®¾ç½®é¡¹  41æ•°æ® *///
1763          ///**********************************************************************///
1764          static uchar8 MultiDataWrite_Deal( uchar8 v_ucChID )    //å¤šæ•°æ®é¡¹ç»„åˆè®¾ç½®
1765          {
1766   1              uchar8          V_ucErrorType = API_DLT645_COMM_ERR_NOAUTH;     /*å¯†ç é”™æœªæˆæƒ*/
1767   1              uchar8          P_ucTemp[35];                           /*ç”¨äºå­˜æ”¾ä¸´æ—¶æ•°æ®ï¼Œå……å€¼æ•°æ®åŠå†™e2æ•°æ®*/
1768   1              uchar8          V_ucTempData[70];                       /*ç”¨äºå­˜å‚¨è¿”å›çš„æ•°æ®*/
1769   1              uchar8          V_DATALen,V_DATALen1,i,j,NN;/*V_DATALenä¸ºå„æ•°æ®çš„é•¿åº¦ï¼›V_DATALen1ä¸ºBUffä¸­å„æ•°æ®çš„å
             -ç§»é‡ï¼›i,jä¸ºä¸´æ—¶å˜é‡ï¼›NNä¸ºè¦è®¾ç½®çš„æ•°æ®é¡¹é¡¹æ•°*/
1770   1              uchar8          V_ucMoneyflag = 0;                      /*ç”¨ä¸è®°å½•æ˜¯å¦æœ‰å……å€¼ä¸šåŠ¡*/
1771   1              uchar8          V_ucDATANum = 0;                        /*ç”¨ä¸åˆ¤å®šæ•°æ®é¡¹é¡¹æ•°æ˜¯å¦ä¸€è‡´*/
1772   1              ulong32         V_ulDI3DI2DI1DI0[10];           /*å¤šé¡¹æ•°æ®è®¾ç½®çš„6ä¸ªæ•°æ®æ ‡è¯†ï¼Œä¸€æ¬¡æœ€å¤šè®¾ç½®6ä¸ªæ•°æ®*/
1773   1              uchar8          V_ucDATAOffset[11];                     /*å¤šé¡¹è®¾ç½®å‰6ä¸ªæ•°æ®é¡¹çš„åç§»é‡:*/
1774   1              uchar8          V_ucDATALen[10];                        /*å¤šé¡¹è®¾ç½®6ä¸ªæ•°æ®é¡¹çš„é•¿åº¦*/
1775   1              ushort16        V_usStateFlag3;                         /*è¿è¡ŒçŠ¶æ€å­—3*/
1776   1              uchar8          AlarmMoneyL1_Set,AlarmMoneyL2_Set;/*æŠ¥è­¦é‡‘é¢1ã€2è®¾ç½®æ ‡å¿—*/
1777   1      
1778   1              NN  = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0];            /*è¦è®¾ç½®çš„æ•°æ®é¡¹é¡¹æ•°*/
1779   1      
1780   1              if((0==(GStr_Flag.ucRunState2&F_RUN_INTAUTHAvailabilityFlag))||(GStr_Flag.ucRunState2&F_RUN_INTAUTH_MACNu
             -mErrFlag))
1781   1              {
1782   2                      return(API_DLT645_COMM_ERR_OTHER);
1783   2              }       /*98\99çº§å¯†ç èº«ä»½è®¤è¯å¤±æ•ˆå’Œèº«ä»½è®¤è¯æŒ‚èµ·ï¼Œ å›å¯†ç é”™*/
1784   1              if( 0x99 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0] )
1785   1              {
1786   2                      return(API_DLT645_COMM_ERR_NOAUTH);
1787   2              }       /*ç”µä»·å‚æ•°éœ€99çº§å¯†çº§è®¾ç½®*/
1788   1              
1789   1              /*åˆ¤æ–­ç¬¬ä¸€ä¸ªæ•°æ®æ ‡è¯†æ˜¯ä¸æ˜¯å……å€¼*/
1790   1              V_ulDI3DI2DI1DI0[0]  = (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W];                /*API_DLT645_D0
             -_Wï¼Œç¬¬ä¸€ä¸ªDIæ•°æ®å……å€¼é‡‘é¢+è´­ç”µæ¬¡æ•°*/     
1791   1              V_ulDI3DI2DI1DI0[0] |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+1]<<8;           
1792   1              V_ulDI3DI2DI1DI0[0] |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+2]<<16;
1793   1              V_ulDI3DI2DI1DI0[0] |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+3]<<24;
1794   1      
1795   1              if( 0x070102FF == V_ulDI3DI2DI1DI0[0])          /*å­˜åœ¨å……å€¼ä¸šåŠ¡*/
1796   1              {
1797   2                      V_ucMoneyflag = 1;                      /*ç¬¬ä¸€ä¸ªæ•°æ®é¡¹ä¸ºå……å€¼ï¼Œä¸‹ä¸ªæ•°æ®æ”¾åœ¨ç¬¬2ä¸ªbuffä¸­*/
1798   2                      V_ucDATANum = 1;
1799   2                      V_ucDATAOffset[0] = 0x00;
1800   2                      V_ucDATAOffset[1] = 0x1A;               /*å……å€¼26ä¸ªå­—èŠ‚ï¼š070102FF+å……å€¼é‡‘é¢+è´­ç”µæ¬¡æ•°+MAC+å®¢æˆ·ç¼–å·+MAC
             -*/
1801   2                      V_ucDATALen[0] = 0x12;
1802   2              }
1803   1              else
1804   1              {
1805   2                      V_ucDATAOffset[0] = 0x00;
1806   2                      V_ucMoneyflag = 0;                      /*ç¬¬ä¸€ä¸ªæ•°æ®é¡¹ä¸ä¸ºå……å€¼ï¼Œç¬¬ä¸€ä¸ªä¸ªæ•°æ®æ”¾åœ¨ç¬¬1ä¸ªbuffä¸­*/
1807   2                      V_ucDATANum = 0;
1808   2              }
1809   1      
1810   1              for(i=V_ucMoneyflag; i<NN; i++) /*åˆ¤æ–­è®¾ç½®çš„æ•°æ®é¡¹æ˜¯å¦åœ¨Comm_MAP_TABè¡¨æ ¼ä¸­*/
1811   1              {
1812   2                      V_ulDI3DI2DI1DI0[i]  = (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+V_ucDATAOffset[i]
             -];                /*API_DLT645_D0_Wï¼Œç¬¬ä¸€ä¸ªDIæ•°æ®å……å€¼é‡‘é¢+è´­ç”µæ¬¡æ•°*/        
1813   2                      V_ulDI3DI2DI1DI0[i] |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+V_ucDATAOffset[i]
             -+1]<<8;
1814   2                      V_ulDI3DI2DI1DI0[i] |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+V_ucDATAOffset[i]
             -+2]<<16;
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 33  

1815   2                      V_ulDI3DI2DI1DI0[i] |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+V_ucDATAOffset[i]
             -+3]<<24;
1816   2      
1817   2                      for(j=0; j<MAX_Comm_MAP_TAB; j++)
1818   2                      {
1819   3                              if(V_ulDI3DI2DI1DI0[i] == Comm_MAP_TAB[j].ucaDataId)
1820   3                              {
1821   4                                      V_ucDATALen[i] = Comm_MAP_TAB[j].ucaDataLen;
1822   4                                      V_ucDATAOffset[i+1] = V_ucDATAOffset[i] + V_ucDATALen[i]+4+4;   /*æ•°æ®é•¿åº¦+æ ‡è¯†ç +MAC*/
1823   4                                      V_ucDATANum++;
1824   4                              }
1825   3                      }
1826   2                      if(_FAILED==LibPub_IsBCD(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_ucDATAOffset[i]], V_
             -ucDATALen[i]) )
1827   2                      {
1828   3                              return ( API_DLT645_COMM_ERR_OTHER );           /*æ•°æ®ä¸æ˜¯BCDç ï¼Œè¿”å›å…¶ä»–é”™è¯¯*/
1829   3                      }                       
1830   2              }
1831   1              if( V_ucDATANum != NN)
1832   1              {
1833   2                      return ( API_DLT645_COMM_ERR_OTHER );                   /*æ•°æ®é¡¹æ•°å¯¹ä¸ä¸Šï¼Œè¿”å›å…¶ä»–é”™è¯¯*/          
1834   2              }
1835   1      
1836   1              /*æ ¼å¼æ­£ç¡®ï¼Œç»„ç»‡è¿”å›æ•°æ®å¸§çš„æ•°æ®æ ‡è¯†ï¼Œæ•°æ®æ ‡è¯†+é”™è¯¯ç‰¹å¾å­—ï¼ˆ5å­—èŠ‚ï¼‰*/
1837   1              for(i=0; i<NN; i++)
1838   1              {
1839   2                      V_ucTempData[i*5+0]     = (V_ulDI3DI2DI1DI0[i])     & 0xFF;
1840   2                      V_ucTempData[i*5+1]     = (V_ulDI3DI2DI1DI0[i]>>8)  & 0xFF;     
1841   2                      V_ucTempData[i*5+2]     = (V_ulDI3DI2DI1DI0[i]>>16) & 0xFF;     
1842   2                      V_ucTempData[i*5+3]     = (V_ulDI3DI2DI1DI0[i]>>24) & 0xFF;
1843   2                      V_ucTempData[i*5+4]     = 0x00;         /*é»˜è®¤è®¾ç½®æˆåŠŸ*/
1844   2                      #if (METER_TYPE != METER_TYPE_DTSY666)          /*å¯¼è½¨è¡¨å’Œå•ç›¸è¡¨ä¸èƒ½è®¾ç½®ç”µæµç”µå‹äº’æ„Ÿå™¨å˜æ¯”*/
1845   2                      {               
1846   3                              if((V_ulDI3DI2DI1DI0[i] == 0x04000306)||(V_ulDI3DI2DI1DI0[i] == 0x04000307))
1847   3                              V_ucTempData[i*5+4] = 0x01;             /*ç”µæµã€ç”µå‹äº’æ„Ÿå™¨å˜æ¯”è®¾ç½®å¤±è´¥*/
1848   3                      }
1849   2                      #endif
1850   2                      if(V_ulDI3DI2DI1DI0[i] == 0x04001001)                   /*æœ‰è®¾ç½®1çº§2çº§æŠ¥è­¦é‡‘é¢*/
1851   2                      {
1852   3                              AlarmMoneyL1_Set = ((i<<4)|0x01)&0xFF;          /*å‰å››ä½è¡¨ç¤ºåœ¨å“ªä¸ªæ•°æ®æ ‡è¯†ï¼Œåå››ä½é0è¡¨ç¤ºæœ‰
             -è¿™ä¸ªæ ‡å¿—*/
1853   3                      }
1854   2                      else if(V_ulDI3DI2DI1DI0[i] == 0x04001002)
1855   2                      {
1856   3                              AlarmMoneyL2_Set = ((i<<4)|0x01)&0xFF;          /*å‰å››ä½è¡¨ç¤ºåœ¨å“ªä¸ªæ•°æ®æ ‡è¯†ï¼Œåå››ä½é0è¡¨ç¤ºæœ‰
             -è¿™ä¸ªæ ‡å¿—*/
1857   3                      }
1858   2              }
1859   1      
1860   1              /*éœ€è®¾ç½®æŠ¥è­¦é‡‘é¢ï¼Œ2çº§æŠ¥è­¦è¦æ¯”1çº§æŠ¥è­¦å°*/
1861   1              if( (AlarmMoneyL1_Set & 0x01)&(AlarmMoneyL2_Set & 0x01) )
1862   1              {
1863   2                      LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_ucDATAOffset[AlarmMon
             -eyL1_Set>>0x04]],P_ucTemp,4);         /*1çº§æŠ¥è­¦é‡‘é¢*/
1864   2                      LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_ucDATAOffset[AlarmMon
             -eyL2_Set>>0x04]],P_ucTemp+4,4);               /*2çº§æŠ¥è­¦é‡‘é¢*/
1865   2                      if(C_GreaterThan!=LibPub_CompareData(P_ucTemp, P_ucTemp+4, 4, CMP_MODE_HIGHT))
1866   2                      {
1867   3                              V_ucTempData[4+5*(AlarmMoneyL1_Set>>0x04)] = 0x01;              /*1çº§æŠ¥è­¦é‡‘é¢è®¾ç½®å¤±è´¥*/
1868   3                              V_ucTempData[4+5*(AlarmMoneyL2_Set>>0x04)] = 0x01;              /*2çº§æŠ¥è­¦é‡‘é¢è®¾ç½®å¤±è´¥*/
1869   3                      }
1870   2              }
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 34  

1871   1              /*åªè®¾æŠ¥è­¦é‡‘é¢1ï¼Œä¸è®¾æŠ¥è­¦é‡‘é¢2*/
1872   1              else if( AlarmMoneyL1_Set & 0x01 )
1873   1              {
1874   2                      LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_ucDATAOffset[AlarmMon
             -eyL1_Set>>0x04]],P_ucTemp,4);         /*1çº§æŠ¥è­¦é‡‘é¢*/
1875   2                      if(C_GreaterThan!=LibPub_CompareData(P_ucTemp, GStr_MoneyPara.ucaAlarmMoneyL2, 4, CMP_MODE_HIGHT))
1876   2                      {
1877   3                              V_ucTempData[4+5*(AlarmMoneyL1_Set>>0x04)] = 0x01;              /*1çº§æŠ¥è­¦é‡‘é¢è®¾ç½®å¤±è´¥*/
1878   3                      }
1879   2              }
1880   1              /*åªè®¾æŠ¥è­¦é‡‘é¢2ï¼Œä¸è®¾æŠ¥è­¦é‡‘é¢1*/
1881   1              else if( AlarmMoneyL2_Set & 0x01 )
1882   1              {
1883   2                      LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_ucDATAOffset[AlarmMon
             -eyL2_Set>>0x04]],P_ucTemp,4);         /*1çº§æŠ¥è­¦é‡‘é¢*/
1884   2                      if(C_GreaterThan!=LibPub_CompareData(GStr_MoneyPara.ucaAlarmMoneyL1, P_ucTemp, 4, CMP_MODE_HIGHT))
1885   2                      {
1886   3                              V_ucTempData[4+5*(AlarmMoneyL2_Set>>0x04)] = 0x01;              /*1çº§æŠ¥è­¦é‡‘é¢è®¾ç½®å¤±è´¥*/
1887   3                      }
1888   2              }
1889   1      
1890   1              /*æœ‰å……å€¼å…ˆè¿›è¡Œå……å€¼è®¾ç½® 0x070102FF+å……å€¼é‡‘é¢+è´­ç”µæ¬¡æ•°+MAC+å®¢æˆ·ç¼–å·+MAC*/    
1891   1              if( 0x070102FF == V_ulDI3DI2DI1DI0[0] )         
1892   1              {
1893   2                      /*æ•°æ®æ ‡è¯†DIï¼Œ4å­—èŠ‚*/
1894   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W], &P_ucTemp[0], 0x04 );              /*è€
             -è“ç‰™åè®®ç¬¬26ä¸ªæ•°æ®*/ 
1895   2                      /*LibPub_Inverse( &P_ucTemp[0], 4 );æ•°æ®æ ‡è¯†DIæ•°æ®å€’å‘*/
1896   2                      
1897   2                      /*æ“ä½œè€…ä»£ç ï¼Œ4å­—èŠ‚*/
1898   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W-4], &P_ucTemp[4], 0x04 );    /*è
             -€è“ç‰™åè®®ç¬¬22ä¸ªæ•°æ®*/        
1899   2      
1900   2                      /*å……å€¼é‡‘é¢+è´­ç”µæ¬¡æ•°+MACï¼Œ12å­—èŠ‚*/
1901   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4], &P_ucTemp[8], 0x0C );    /*è
             -€è“ç‰™åè®®ç¬¬30ä¸ªæ•°æ®*/
1902   2      
1903   2                      /*å®¢æˆ·ç¼–å·+MACï¼Œ10å­—èŠ‚*/
1904   2                      LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+16], &P_ucTemp[20], 0x0A );  /
             -*è€è“ç‰™åè®®ç¬¬42ä¸ªæ•°æ®*/
1905   2      
1906   2                      /*å……å€¼æ“ä½œï¼Œè¿”å›å……å€¼æ˜¯å¦æˆåŠŸ*/
1907   2                      V_ucTempData[4] = PrepaymentModule_Comm_OpenAccout(&P_ucTemp[0]);
1908   2              }
1909   1      
1910   1              /*0x04001001:æŠ¥è­¦é‡‘é¢1+MAC  0x04001002:æŠ¥è­¦é‡‘é¢2+MAC  0x04000306:CT+MAC  0x04000307:PT+MAC  0x040
             -01003:é€æ”¯é‡‘é¢é™å€¼+MAC*/
1911   1              for( i=V_ucMoneyflag; i<NN; i++ )               /*i=1,æœ‰å……å€¼ï¼›i=0ï¼Œæ— å……å€¼*/
1912   1              {
1913   2                      for( j=0; j<MAX_Comm_MAP_TAB; j++ )
1914   2                      {
1915   3                              if( V_ulDI3DI2DI1DI0[i] == Comm_MAP_TAB[j].ucaDataId )
1916   3                              {
1917   4                                      if( _TRUE != Comm_MAP_TAB[j].IsWrite )   
1918   4                                      {
1919   5                                              V_ucTempData[i*5+4] = 0x02;             /*ä¸æ”¯æŒå†™çš„æ•°æ®å›02*/
1920   5                                      }
1921   4      
1922   4                                      V_DATALen1 = V_ucDATAOffset[i];                         /*BUffä¸­å„æ•°æ®çš„åç§»é‡*/
1923   4                                      V_DATALen = Comm_MAP_TAB[j].ucaDataLen;         /*å„æ•°æ®çš„é•¿åº¦*/
1924   4                                      LibPub_Inverse( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_DATALen1], V_DATALen );/*æ•
             -°æ®å€’åº*/
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 35  

1925   4                                      LibPub_Inverse( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_DATALen1+V_DATALen], 4 ); /
             -* MACå€’åº*/
1926   4                                      if( C_ERR == PrepaymentModule_CommWriteESAMBinaryMAC( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT64
             -5_D0_W+4+V_DATALen1], V_DATALen, 11, 0x01) )
1927   4                                      { 
1928   5                                              V_ucTempData[i*5+4] = 0x04;             /*MACæ ¡éªŒå¤±è´¥*/
1929   5                                      }
1930   4                                      if(V_ucTempData[i*5+4] == 0x00)         /*éƒ½æ­£ç¡®åˆ™å†™å‚æ•°*/
1931   4                                      {
1932   5                                              LibPub_MemCopyBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_DATALen1], Comm_MAP_T
             -AB[j].ucaRamAdd, V_DATALen);
1933   5                                              LibPub_Inverse( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_DATALen1], V_DATALen );      /*
             -æ•°æ®å€’åº*/
1934   5                                              /*æ›´æ–°RAMå’ŒEE,RAMçš„CRCæš‚æ—¶ä¸ç®—ï¼Œæ•ˆéªŒé”™ä¹‹åç›´æ¥ä»EEæ›´æ–°*/
1935   5                                              LibPub_ReadDataFromE2prom(Comm_MAP_TAB[j].ucaE2pIndex,0,P_ucTemp);              /*å°†EEå†…æ•°æ®è¯»å‡ºç®—CRC*/
1936   5                                              LibPub_MemExchangeBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_W+4+V_DATALen1],&P_ucTe
             -mp[Comm_MAP_TAB[j].ucaE2offset] , Comm_MAP_TAB[j].ucaDataLen);
1937   5                                              LibPub_WriteDataToE2prom( Comm_MAP_TAB[j].ucaE2pIndex,0,P_ucTemp );             /*å†™å…¥EE*/
1938   5                                      }
1939   4                              }
1940   3                      }
1941   2              }
1942   1      
1943   1              /*å½“å‰æ€»ç”µé‡4å­—èŠ‚ 5*NN*/
1944   1              LibPub_MemExchangeBytes(&GStr_Energy.ucaFw_Energy[0], &V_ucTempData[5*NN], 0x04 );
1945   1      
1946   1              /*æ€»è´­ç”µé‡‘é¢4å­—èŠ‚*/
1947   1              LibPub_MemExchangeBytes(&GStr_PRICE.ucaPurchaseMoneyAll[0], &V_ucTempData[5*NN+4], 0x04 );
1948   1      
1949   1              /*è´­ç”µæ¬¡æ•°4å­—èŠ‚*/
1950   1              LibPub_MemExchangeBytes(&GStr_PRICE.ucPurchaseTimes[0], &V_ucTempData[5*NN+8], 0x04 );
1951   1      
1952   1              /*è¡¨å†…å‰©ä½™é‡‘é¢4å­—èŠ‚*/
1953   1              LibPub_MemExchangeBytes(&GStr_Money.ucaRemainMoney[0], &V_ucTempData[5*NN+12], 0x04 );
1954   1      
1955   1              /*è¡¨å†…é€æ”¯é‡‘é¢4å­—èŠ‚*/
1956   1              LibPub_MemExchangeBytes(GStr_Money.ucaTickMoney, &V_ucTempData[5*NN+16], 0x04 );
1957   1      
1958   1              /*çŠ¶æ€å­—3 2å­—èŠ‚*/
1959   1              V_usStateFlag3=ApiDLT645_GetStatusFlag3();
1960   1              V_ucTempData[5*NN+20]=(uchar8)V_usStateFlag3;
1961   1              V_ucTempData[5*NN+21]=(uchar8)(V_usStateFlag3>>8);
1962   1      
1963   1              LibPub_MemCopyBytes( V_ucTempData, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], 5*NN+22);   
1964   1      
1965   1              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 5*NN+26;/*è¿”å›æ•°æ®çš„é•¿åº¦ï¼ŒåŒ…å«äº†4ä¸ªå­
             -—èŠ‚çš„æ ‡è¯†ç */
1966   1              
1967   1              return(API_DLT645_COMM_ERR_OK);
1968   1      }
1969          
1970          ///**********************************************************************///
1971          ///* Brief: è´¹æ§å‘½ä»¤                                                     *///
1972          ///*                                                                    *///
1973          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
1974          ///*                                                                    *///
1975          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
1976          ///*                                                                    *///
1977          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
1978          ///**********************************************************************///
1979          uchar8 ApiDLT645_RelayControl(uchar8 v_ucChID)
1980          {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 36  

1981   1      ///FE FE FE FE 68 03 00 00 00 00 00 68 1C 10 36 33 33 33 45 33 33 33 4D 33 33 33 33 34 34 CC F9 16 
1982   1              uchar8      V_ucTemp;
1983   1              uchar8          V_ucErrorType = API_DLT645_COMM_ERR_NODATA;     ///* æ— è¯·æ±‚æ•°æ® *///
1984   1              
1985   1              if  (Gstr_UartComm[v_ucChID].ucCommAddrType != F_COMMADDRTYPE_ID)       /* å…¨åœ°å€ç›¸ç­‰æ‰å¯ä»¥æ“ä½œ */
1986   1              {
1987   2                      return V_ucErrorType;
1988   2              }
1989   1      
1990   1              if(0x98 == Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA])
1991   1              {
1992   2                      if((!(GStr_Flag.ucRunState2&F_RUN_INTAUTHAvailabilityFlag))||(GStr_Flag.ucRunState2&F_RUN_INTAUTH_MACNum
             -ErrFlag))///*èº«ä»½è®¤è¯æœ‰æ•ˆæ ‡å¿—å¤±æ•ˆ||èº«ä»½è®¤è¯æŒ‚èµ·*///
1993   2                      {
1994   3                              return API_DLT645_COMM_ERR_NOAUTH;
1995   3                      }
1996   2                      V_ucTemp = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]-12;
1997   2                      LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_C0], V_ucTemp);        
1998   2                      LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_C0+V_ucTemp], 4);      
1999   2                      if(C_ERR==PrepaymentModule_DataDecription(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_C0], 17, &V_
             -ucTemp))
2000   2                      {
2001   3                              V_ucErrorType=API_DLT645_COMM_ERR_NOAUTH;
2002   3                              return V_ucErrorType;
2003   3                      }
2004   2                      LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_C0], V_ucTemp);        
2005   2              }
2006   1              else if(0x02 == Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA])
2007   1              {
2008   2                      if(!(GStr_Flag.ucMeterMode&F_FACTORY_MODE))
2009   2                      {
2010   3                              if(_FAILED==LibPub_CheckPassword(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]))
2011   3                              {
2012   4                                      return API_DLT645_COMM_ERR_NOAUTH;
2013   4                              }
2014   3                      }
2015   2              }
2016   1              else
2017   1              {
2018   2                      return API_DLT645_COMM_ERR_NOAUTH;
2019   2              }
2020   1                      
2021   1              
2022   1              
2023   1              switch(Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_C0])   ///ç¬¬22ä½ä¸ºå‘½ä»¤ç 
2024   1              {
2025   2                      case 0x1A:                  ///* è·³é—¸
2026   2                      {
2027   3                              if(F_RUN_KEEP_ELEC==(GStr_Flag.ucRunState&F_RUN_KEEP_ELEC))  ///ä¿ç”µ
2028   3                              {
2029   4                                      return (API_DLT645_COMM_ERR_NOAUTH);
2030   4                              }               
2031   3                              GStr_Flag.ucRunState |= F_RUN_COMM_RELAYOFF;
2032   3                              ApiRelay_ControlProcess();
2033   3                              LibPub_WriteDataToE2prom(LIB_E2P_RUN_STATE,0,&GStr_Flag.ucRunState);
2034   3                              V_ucErrorType=API_DLT645_COMM_ERR_OK;
2035   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
2036   3                      }break;
2037   2                      
2038   2              case 0x1C:                ///*åˆé—¸
2039   2                      {
2040   3                              if(F_RUN_DISABLE_CLOSE==(GStr_Flag.ucRunState&F_RUN_DISABLE_CLOSE))
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 37  

2041   3                              {
2042   4                                      return (API_DLT645_COMM_ERR_NOAUTH);
2043   4                              }
2044   3                              
2045   3                              if(GStr_Flag.ucRunState1&F_RUN_L2_ALRAM)        /*ä¸å°ç¨‹åºåŒ¹é…ï¼ŒäºŒçº§æŠ¥è­¦å’Œè¿‡é›¶åªè¦æœ‰é€šä¿¡åˆ
             -é—¸å‘½ä»¤å°±åˆé—¸*/
2046   3                              {
2047   4                                      GStr_Flag.ucRunState|=F_RUN_CLOSE_L2;
2048   4                              }
2049   3                              if(GStr_Flag.ucRunState1&F_RUN_REMAIND_ZERO)
2050   3                              {
2051   4                                      GStr_Flag.ucRunState|=F_RUN_CLOSE_ZERO;
2052   4                              }
2053   3      
2054   3                              GStr_Flag.ucRunState &=~F_RUN_COMM_RELAYOFF;            
2055   3                              GStr_Flag.ucRunState1 &=~F_RUN_OVER_DEMAND_CLOSE;    ///åˆé—¸ï¼Œæ¸…é™¤è¿‡è½½æ¢å¤åˆé—¸æ ‡å¿—
2056   3                              ApiRelay_ControlProcess();
2057   3                              LibPub_WriteDataToE2prom(LIB_E2P_RUN_STATE,0,&GStr_Flag.ucRunState);
2058   3                              V_ucErrorType=API_DLT645_COMM_ERR_OK;
2059   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
2060   3                      }break;
2061   2                      
2062   2                      case 0x3A:              ///*ä¿ç”µ
2063   2                      {
2064   3                              GStr_Flag.ucRunState  |=F_RUN_KEEP_ELEC;                
2065   3                              GStr_Flag.ucRunState1 &=~F_RUN_OVER_DEMAND_CLOSE;    ///ä¿ç”µè‡ªåŠ¨åˆé—¸ï¼Œæ¸…é™¤è¿‡è½½æ¢å¤åˆé—¸æ 
             -‡å¿—
2066   3                              ApiRelay_ControlProcess();
2067   3                              LibPub_WriteDataToE2prom(LIB_E2P_RUN_STATE,0,&GStr_Flag.ucRunState);
2068   3                              V_ucErrorType=API_DLT645_COMM_ERR_OK;
2069   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
2070   3                      }break;
2071   2                      
2072   2                      case 0x3B:              ///*ä¿ç”µè§£é™¤
2073   2                      {
2074   3                              GStr_Flag.ucRunState &=~F_RUN_KEEP_ELEC;                
2075   3                              ApiRelay_ControlProcess();
2076   3                              LibPub_WriteDataToE2prom(LIB_E2P_RUN_STATE,0,&GStr_Flag.ucRunState);
2077   3                              V_ucErrorType=API_DLT645_COMM_ERR_OK;
2078   3                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
2079   3                      }break;
2080   2                      default :
2081   2                      return API_DLT645_COMM_ERR_NODATA;
2082   2              }
2083   1              
2084   1          return  V_ucErrorType;
2085   1      
2086   1      }
2087          
2088          
2089          
2090          ///**********************************************************************///
2091          ///* Brief:  å‚å†…è‡ªæ‰©å‘½ä»¤                                                *///
2092          ///*                                                                    *///
2093          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
2094          ///*                                                                    *///
2095          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
2096          ///*                                                                    *///
2097          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
2098          ///**********************************************************************///
2099          static uchar8 ApiDLT645_FactoryCommand( uchar8 v_ucChID )
2100          {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 38  

2101   1              uchar8          V_ucErrorType = API_DLT645_COMM_ERR_NODATA;     ///* æ— è¯·æ±‚æ•°æ® *///
2102   1              uchar8          V_ucTempdata;
2103   1              ushort16        V_usAddress; 
2104   1      //      uchar8    V_ucTempData08[3];
2105   1              ulong32         V_ulDI3DI2DI1DI0,V_ulTempData32;
2106   1      
2107   1              
2108   1              V_ulDI3DI2DI1DI0  = (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0];
2109   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+1]<<8;
2110   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+2]<<16;
2111   1              V_ulDI3DI2DI1DI0 |= (ulong32) Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3]<<24;
2112   1              
2113   1              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_CMD] == API_DLT645_CMD_FACTORY_1E )
2114   1              {
2115   2                      if (  V_ulDI3DI2DI1DI0 == 0xFFFFFFFF ) 
2116   2                      {
2117   3                              switch( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+4] )
2118   3                              {
2119   4                                      ///* è¯»E2:     FE FE FE FE 68 00 00 00 00 00 00 68 1E 0A 32 32 32 32 33 67 45 33 33 43 48 16 *///
2120   4                                      ///* è¯»RAM:    FE FE FE FE 68 00 00 00 00 00 00 68 1E 0A 32 32 32 32 34 67 45 33 33 43 49 16 *///
2121   4      
2122   4                                      case 0x00:      ///* è¯»RAM *///
2123   4                                      case 0x01:      ///* è¯»E2  *///  æ•°æ®ä¸å€’åº
2124   4                                      {
2125   5                                              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] == 0x0A )
2126   5                                              {
2127   6                                                      if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+9] <= 32 )        ///* ä¸€æ¬¡åªèƒ½æŠ„è¯»32å
             -­—èŠ‚
2128   6                                                      {
2129   7                                                              V_usAddress  = ((ushort16)Gstr_UartComm[v_ucChID].ucaCommTXBuff[20]<<8) & 0xff00;                                       
2130   7                                                              V_usAddress |= ((ushort16)Gstr_UartComm[v_ucChID].ucaCommTXBuff[19]) & 0x00ff;
2131   7                                                              V_ucTempdata = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+9];
2132   7                                                              
2133   7                                                              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+4] == 0 ) ///* è¯»RAM *///
2134   7                                                              {
2135   8                                                                      if( (V_usAddress+V_ucTempdata) > 0x1f00)        // åœ°å€+é•¿åº¦è¶…è¿‡æœ€å¤§åœ°å€ï¼Œåˆ™ç›´æ¥é€€å‡º
2136   8                                                                      {
2137   9                                                                              break;
2138   9                                                                      }
2139   8                                                                      LibPub_MemCopyBytes( (uchar8 xdata*)(V_usAddress), &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT
             -645_D0_R], V_ucTempdata);
2140   8                                                              }
2141   7                                                              else    ///* è¯»E2 *///
2142   7                                                              {
2143   8                                                                      DrvE2p_ReadData( V_usAddress, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], V_ucTempda
             -ta);                                                        
2144   8                                                                      
2145   8                                                                      ///* å¦‚æœè¯»å–çš„e2åœ°å€åŒ…å«å¯†ç åœ°å€ï¼Œåˆ™è¿”å›æ•°æ®ç”¨FFå¡«å……ï¼Œå‚å¤–é€‚ç”¨ *///
2146   8                                                                      if ( F_FACTORY_MODE != (GStr_Flag.ucMeterMode & F_FACTORY_MODE ) )
2147   8                                                                      {
2148   9                                                                              ///* åœ°å€å°äºå¯†ç åœ°å€ï¼Œåœ°å€+é•¿åº¦å¤§äºç­‰äºå¯†ç åœ°å€ *///
2149   9                                                                              if( V_usAddress <= EEPROM_MAP_TAB[LIB_E2P_Password].usE2pAddress )
2150   9                                                                              {
2151  10                                                                                      if( (V_usAddress+V_ucTempdata) >= EEPROM_MAP_TAB[LIB_E2P_Password].usE2pAddress ) 
2152  10                                                                                      {
2153  11                                                                                              LibPub_MemSetBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], 0xff, V_ucTempdat
             -a );
2154  11                                                                                      }
2155  10                                                                              }///* åœ°å€å¤§äºå¯†ç åœ°å€ï¼Œä½†å°äºå¯†ç åœ°å€+é•¿åº¦ *///
2156   9                                                                              else if(  ( V_usAddress <= EEPROM_MAP_TAB[LIB_E2P_Password].usE2pAddress + EEPROM_MAP_TAB[LIB_E2
             -P_Password].ucE2pLen ) )
2157   9                                                                              {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 39  

2158  10                                                                                      LibPub_MemSetBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], 0xff, V_ucTempdata
             - );
2159  10                                                                              }
2160   9                                                                      }
2161   8                                                              }
2162   7                                                              
2163   7                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 4+V_ucTempdata;                         
2164   7                                                              
2165   7                                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2166   7                                                      }
2167   6                                              }
2168   5                                      }break;
2169   4                              ///* è¯»ç±»EEï¼šFE FE FE FE 68 00 00 00 00 00 00 68 1E 0A 32 32 32 32 35 67 45 33 33 43 49 16 *///
2170   4                                      case 0x02:  ///* è¯»ç±»EE*///
2171   4                                      {
2172   5                                                      if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] == 0x0A )
2173   5                                                      {
2174   6                                                                      if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+9] <= 128 )       ///* ä¸€æ¬¡æœ€å¤šæŠ„è¯»1
             -28å­—èŠ‚
2175   6                                                                      {
2176   7                                                                                              V_usAddress  = ((ushort16)Gstr_UartComm[v_ucChID].ucaCommTXBuff[20]<<8) & 0xff00;                                       
2177   7                                                                                              V_usAddress |= ((ushort16)Gstr_UartComm[v_ucChID].ucaCommTXBuff[19]) & 0x00ff;
2178   7                                                                                              V_ucTempdata = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+9];
2179   7                                                                                  
2180   7                                                                                              if(0xFF==Hal_ReadEEPROM( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], V_usAddress, 
             -V_ucTempdata))
2181   7                                                                                              {
2182   8                                                                                                              break;
2183   8                                                                                              }
2184   7                                                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 4+V_ucTempdata;                         
2185   7                                                                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2186   7                                                                      }
2187   6                                                      }
2188   5                                      
2189   5                                      }break;
2190   4                                      ///* è®¾ç½®è½¯I_J FE FE FE FE 68 AA AA AA AA AA AA 68 1E 09 32 32 32 32 4D F3 DB 33 33 3C 16  *///
2191   4                                      case 0x1A:
2192   4                                      {
2193   5                                              V_ucErrorType = API_DLT645_COMM_ERR_NOAUTH;
2194   5                                              ///* æ•°æ®é•¿åº¦ä¸ä¸º9ï¼Œåˆ™é€€å‡º *///
2195   5                                              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] == 0x09 )
2196   5                                              {
2197   6                                                      ///* å‡†å¤‡ä¸€ä¸‹æ•°æ® */// 
2198   6                                                      LibPub_MemExchangeBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5] ,( uchar8*)&V
             -_ulTempData32, 4 );
2199   6                                                      
2200   6                                                      if ( F_KEY_ACKTION_DOWN != (GStr_Flag.ucFactoryKey & F_KEY_ACKTION_DOWN) )
2201   6                                                      {
2202   7                                                              if( V_ulTempData32!= 0 ) break;
2203   7                                                      }
2204   6                                                      
2205   6                                                      if( V_ulTempData32 > FACTORY_MAX_TIME) break;
2206   6                                                      
2207   6                                                      GStr_Monitor.ulSoftI_JTime = V_ulTempData32;
2208   6                                                      
2209   6                                                      if( GStr_Monitor.ulSoftI_JTime == 0 )
2210   6                                                      {
2211   7                                                              GStr_Flag.ucMeterMode &= ~F_FACTORY_MODE;
2212   7                                                      }
2213   6                                                      else
2214   6                                                      {
2215   7                                                              GStr_Flag.ucMeterMode |= F_FACTORY_MODE;
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 40  

2216   7                                                      }
2217   6                                                      LibPub_WriteDataToE2prom( LIB_E2P_SOFTI_J, 0, (uchar8 *)&GStr_Monitor.ulSoftI_JTime);                                           
2218   6                                                      
2219   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;                                      
2220   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2221   6                                              }
2222   5                                              
2223   5                                      }break;
2224   4                                      
2225   4                                      ///* è¯»è½¯I_J FE FE FE FE 68 AA AA AA AA AA AA 68 1E 09 32 32 32 32 4E 33 33 33 33 D5 16   *///
2226   4                                      case 0x1B:
2227   4                                      {
2228   5                                              LibPub_ReadDataFromE2prom( LIB_E2P_SOFTI_J, 0, (uchar8 *)&GStr_Monitor.ulSoftI_JTime );
2229   5                                              LibPub_MemExchangeBytes( (uchar8 *)&GStr_Monitor.ulSoftI_JTime, &Gstr_UartComm[v_ucChID].ucaCommTXBuf
             -f[API_DLT645_1STDATA+5] , 4 );
2230   5                                              
2231   5                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 9;                                      
2232   5                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2233   5                                      }break;
2234   4                                      
2235   4                                      case 0x2A:////*å†™è“ç‰™å‚æ•°  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 1D 32 32 32 32 5D MAC5 4 3 2 1 
             -0 NAME11 10 9 8 7 6 5 4 3 2 1 0 KEY2 1 0 ucAdvTime1  0  ucBleTPL  cs 16
2236   4                                      {
2237   5                                              if( 0x1D != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2238   5                                              {
2239   6                                                      break;
2240   6                                              }
2241   5                                              
2242   5                                              /*---------------------------------------------------------------------------------------------------
             ----*/
2243   5                                              /* æ›´æ–°å‚æ•°  */
2244   5                                              LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5], &GStr_BLEGroup.
             -ucBleMAC[0], 6);
2245   5                                              LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+11], &GStr_BLEGroup
             -.ucBleName[0], 12);
2246   5                                              LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+23], &GStr_BLEGroup
             -.ucBleKey[0], 3);
2247   5                                              LibPub_MemExchangeBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+26], (uchar8*)&GStr
             -_BLEGroup.usAdvTime, 2);
2248   5                                              GStr_BLEGroup.ucBleTPL=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+28];
2249   5                                              
2250   5                                              /*---------------------------------------------------------------------------------------------------
             ----*/
2251   5                                              /* è®¡ç®—ä¸€ä¸‹crcï¼Œå°†å‚æ•°å†™å…¥E2  */
2252   5                                              GStr_BLEGroup.usCRC16 = LibPub_CRC16_CCITT(&GStr_BLEGroup.ucBleMAC[0], GStr_BLE_GROUP_TypeLEN-2); 
2253   5                                              LibPub_WriteDataToE2prom( LIB_E2P_BLE_PARA, 0, &GStr_BLEGroup.ucBleMAC[0])      ;       
2254   5                                              
2255   5                                              
2256   5                                              /*---------------------------------------------------------------------------------------------------
             ----*/
2257   5                                              GStr_Flag.ucBLESTATFlag = BLE_STAT_MAC_MOD;             //éœ€è¦è®¾ç½®è“ç‰™æ¨¡å—macæ ‡å¿—
2258   5                                              /* å¦‚æœRAMå‚æ•°æœ‰å˜åŒ–ï¼Œé‡æ–°è®¾ç½®ä¸€ä¸‹è“ç‰™å‚æ•°ï¼Œè®¾ç½®æˆå¹¿æ’­æ€ï¼Œè¿™é‡Œä¼šæœ‰å»¶è¿
             -Ÿï¼Œæ‰€ä»¥è¿™å¸§æ•°æ®çš„å›å¤ä¼šå»¶æ—¶è¾ƒé•¿ */
2259   5                                              //BleDrv_BleReset();
2260   5                                              //BleDrv_SetBleRunPara();
2261   5                                              //BleDrv_SetBleStat();
2262   5                                              
2263   5                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
2264   5                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2265   5                                                      
2266   5                                      }break;
2267   4                                              
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 41  

2268   4                                      case 0x2B:      /*è¯»è“ç‰™å‚æ•°  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 09 32 32 32 32 5E 33 33 33 33 cs 
             -16 */
2269   4                                                              /*            9E  17  MAC5..0  name11...0 key3..0  time1 0 */
2270   4                                      {
2271   5                                              if(0x09!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
2272   5                                              {
2273   6                                                      break;
2274   6                                              }       
2275   5                                              
2276   5                                              BleDrv_GetBleMac(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5]);
2277   5                                              LibPub_Inverse(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5], 6);        /*MAC*/
2278   5                                              LibPub_MemExchangeBytes(&GStr_BLEGroup.ucBleName[0],&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645
             -_1STDATA+11], 12);            /*åç§°*/
2279   5                                              LibPub_MemExchangeBytes(&GStr_BLEGroup.ucBleKey[0],&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_
             -1STDATA+23],  3);             /*é…å¯¹ç */
2280   5                                              LibPub_MemExchangeBytes((uchar8*)&GStr_BLEGroup.usAdvTime,&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_
             -DLT645_1STDATA+26],  2);      /*å¹¿æ’­æ—¶é—´*/
2281   5                                              
2282   5                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+28]=GStr_BLEGroup.ucBleTPL;    /*å‘å°„åŠŸç‡*/
2283   5                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x1D;
2284   5                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2285   5                                      }break;
2286   4                                      case 0x20:///è¯»è“ç‰™MAC  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 09 32 32 32 32 53 33 33 33 33 cs 16
2287   4                                      {
2288   5                                              if( 0x09 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2289   5                                              {
2290   6                                                      break;
2291   6                                              }               
2292   5                                              
2293   5                                              if( _SUCCESS == BleDrv_GetBleMac(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]) )
2294   5                                              {
2295   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x06;
2296   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2297   6                                              }
2298   5                                              
2299   5                                      }break;
2300   4                                      
2301   4                                      case 0x21:///è¯»è“ç‰™åç§°  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 09 32 32 32 32 54 33 33 33 33 cs 
             -16
2302   4                                      {
2303   5                                              if( 0x09 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2304   5                                              {
2305   6                                                      break;
2306   6                                              }       
2307   5                                              
2308   5                                              if( _SUCCESS == BleDrv_GetBleName(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]) )
2309   5                                              {
2310   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x0C;
2311   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2312   6                                              }
2313   5                                              
2314   5                                      }break;
2315   4      
2316   4                                      case 0x25:///è¯»è“ç‰™å‘å°„åŠŸç‡  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 09 32 32 32 32 58 33 33 33 
             -33 cs 16
2317   4                                      {
2318   5                                              if( 0x09 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
2319   5                                              {
2320   6                                                      break;
2321   6                                              }               
2322   5                                              
2323   5                                              if(_SUCCESS==BleDrv_GetBleTPL(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]))
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 42  

2324   5                                              {
2325   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x01;
2326   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2327   6                                              }
2328   5                                              
2329   5                                      }break;         
2330   4                                      
2331   4                                      case 0x28:      /* è®¾ç½®è“ç‰™å‘å°„åŠŸç‡   FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 06 32 32 32 32 5B 33 c
             -s 16 */
2332   4                                      {                       /* 1å­—èŠ‚ */   
2333   5                                              if( 0x06 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2334   5                                              {
2335   6                                                      break;
2336   6                                              }               
2337   5                                              if( _SUCCESS == BleDrv_SetBleTPL(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5]))
2338   5                                              {
2339   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x00;
2340   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2341   6                                                      /* è®¡ç®—ä¸€ä¸‹crcï¼Œå°†å‚æ•°å†™å…¥E2  */
2342   6                                                      GStr_BLEGroup.ucBleTPL = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5];
2343   6                                                      GStr_BLEGroup.usCRC16 = LibPub_CRC16_CCITT(&GStr_BLEGroup.ucBleMAC[0], GStr_BLE_GROUP_TypeLEN-2); 
2344   6                                                      LibPub_WriteDataToE2prom( LIB_E2P_BLE_PARA, 0, &GStr_BLEGroup.ucBleMAC[0]);                     
2345   6                                              }       
2346   5                                      }break; 
2347   4                                      
2348   4                                      case 0x29:      /*è®¾ç½®è“ç‰™å·¥ä½œæ¨¡å¼ 01ï¼šä»ï¼ˆä»…åšä»ï¼‰FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 06
             - 32 32 32 32 5C data cs 16*/
2349   4                                      {                       /* 1å­—èŠ‚ */   
2350   5                                              if( 0x06 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2351   5                                              {
2352   6                                                      break;
2353   6                                              }                                                       
2354   5                                              if( _SUCCESS == BleDrv_CommSetBlePara( COMM_BLE_MOD, BLE_TTP_Len, &Gstr_UartComm[v_ucChID].ucaCommTXB
             -uff[API_DLT645_1STDATA+5] ))
2355   5                                              {
2356   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x00;
2357   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2358   6                                              }       
2359   5                                      }break; 
2360   4      
2361   4                                      case 0x30:      /*è¯»è“ç‰™å·¥ä½œæ¨¡å¼ 01ï¼šä»ï¼ˆä»…åšä»ï¼‰FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 1E 09 32
             - 32 32 32 63 33 33 33 33 cs 16*/
2362   4                                      {                       /* 1å­—èŠ‚ */   
2363   5                                              if( 0x09 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2364   5                                              {
2365   6                                                      break;
2366   6                                              }                                                       
2367   5                                              if( _SUCCESS == BleDrv_CommGetBlePara( COMM_BLE_MOD, BLE_TTP_Len, &Gstr_UartComm[v_ucChID].ucaCommTXB
             -uff[API_DLT645_1STDATA] ))
2368   5                                              {
2369   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x01;
2370   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2371   6                                              }       
2372   5                                      }break; 
2373   4      
2374   4                                      case 0x31:      /*è®¾ç½®é€ä¼ åè®® 01ï¼š645åè®®ï¼ˆé»˜è®¤ï¼‰02ï¼š698åè®®FE FE FE FE 68 A0 A1 A2 A3 A4 
             -A5 68 1E 06 32 32 32 32 64 data cs 16*/
2375   4                                      {                       /* 1å­—èŠ‚ */   
2376   5                                              if( 0x06 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2377   5                                              {
2378   6                                                      break;
2379   6                                              }                                                       
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 43  

2380   5                                              if( _SUCCESS == BleDrv_CommSetBlePara( COMM_BLE_TTP, BLE_TTP_Len, &Gstr_UartComm[v_ucChID].ucaCommTXB
             -uff[API_DLT645_1STDATA+5] ))
2381   5                                              {
2382   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x00;
2383   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2384   6                                              }       
2385   5                                      }break; 
2386   4      
2387   4                                      case 0x32:      /*è¯»é€ä¼ åè®® 01ï¼š645åè®®ï¼ˆé»˜è®¤ï¼‰02ï¼š698åè®®FE FE FE FE 68 A0 A1 A2 A3 A4 A5 
             -68 1E 09 32 32 32 32 65 33 33 33 33 cs 16*/
2388   4                                      {                       /* 1å­—èŠ‚ */   
2389   5                                              if( 0x09 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2390   5                                              {
2391   6                                                      break;
2392   6                                              }                                                       
2393   5                                              if( _SUCCESS == BleDrv_CommGetBlePara( COMM_BLE_TTP, BLE_TTP_Len, &Gstr_UartComm[v_ucChID].ucaCommTXB
             -uff[API_DLT645_1STDATA] ))
2394   5                                              {
2395   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x01;
2396   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2397   6                                              }       
2398   5                                      }break; 
2399   4                                      
2400   4                                      case 0x33:      /*è¯»å–å½“å‰è¿æ¥çš„è®¾å¤‡MAC ï¼ˆå¦‚æœæ²¡æœ‰è¿æ¥ï¼Œè¿”å›å…¨FFï¼‰FE FE FE FE 68 A0 A1
             - A2 A3 A4 A5 68 1E 09 32 32 32 32 66 33 33 33 33 cs 16*/
2401   4                                      {                       /* 6å­—èŠ‚ */   
2402   5                                              if( 0x09 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2403   5                                              {
2404   6                                                      break;
2405   6                                              }                                                       
2406   5                                              if( _SUCCESS == BleDrv_CommGetBlePara( COMM_BLE_STAT, BLE_STAT_Len, &Gstr_UartComm[v_ucChID].ucaCommT
             -XBuff[API_DLT645_1STDATA] ))
2407   5                                              {
2408   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x06;
2409   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2410   6                                              }       
2411   5                                      }break; 
2412   4                                      
2413   4                                      case 0x34:      /*æ¨¡å—å›ºä»¶ç‰ˆæœ¬å·ASCIIï¼ˆéœ€å¯¹ç…§ç‰ˆæœ¬æ ¼å¼ï¼‰FE FE FE FE 68 A0 A1 A2 A3 A4 A5 68 
             -1E 09 32 32 32 32 67 33 33 33 33 cs 16*/
2414   4                                      {                       /* 32å­—èŠ‚ */  
2415   5                                              if( 0x09 != Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] )
2416   5                                              {
2417   6                                                      break;
2418   6                                              }                                                       
2419   5                                              if( _SUCCESS == BleDrv_CommGetBlePara( COMM_BLE_MFV, BLE_MFV_Len, &Gstr_UartComm[v_ucChID].ucaCommTXB
             -uff[API_DLT645_1STDATA] ))
2420   5                                              {
2421   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0x20;
2422   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2423   6                                              }       
2424   5                                      }break; 
2425   4                                      
2426   4      //                              case 0x22:///è¯»è“ç‰™key  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 A6 68 1E 09 32 32 32 32 55 33 33 33 33 c
             -s 16
2427   4      //                              {
2428   4      //                                                      if(0x09!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
2429   4      //                                                      {
2430   4      //                                                                      break;
2431   4      //                                                      }               
2432   4      //                                                      if(_SUCCESS==BleDrv_GetBleKey(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]))
2433   4      //                                                      {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 44  

2434   4      //                                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x06;
2435   4      //                                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2436   4      //                                                      }
2437   4      //                                                      else
2438   4      //                                                      {
2439   4      //                                                                      break;
2440   4      //                                                      }
2441   4      //                              }break;
2442   4                                      
2443   4      //                              case 0x23:///è¯»è“ç‰™é…å¯¹ç­‰çº§  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 A6 68 1E 09 32 32 32 32 56 33 3
             -3 33 33 cs 16
2444   4      //                              {
2445   4      //                                                      if(0x09!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
2446   4      //                                                      {
2447   4      //                                                                      break;
2448   4      //                                                      }               
2449   4      //                                                      if(_SUCCESS==BleDrv_GetBleSMPLv(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]))
2450   4      //                                                      {
2451   4      //                                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x01;
2452   4      //                                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2453   4      //                                                      }
2454   4      //                                                      else
2455   4      //                                                      {
2456   4      //                                                                      break;
2457   4      //                                                      }
2458   4      //                              }break;
2459   4                                      
2460   4      //                              case 0x24:///è¯»è“ç‰™å¹¿æ’­å‘¨æœŸ  FE FE FE FE 68 A0 A1 A2 A3 A4 A5 A6 68 1E 09 32 32 32 32 57 33 3
             -3 33 33 cs 16
2461   4      //                              {
2462   4      //                                                      if(0x09!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
2463   4      //                                                      {
2464   4      //                                                                      break;
2465   4      //                                                      }               
2466   4      //                                                      if(_SUCCESS==BleDrv_GetBleADVP(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]))
2467   4      //                                                      {
2468   4      //                                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x05;
2469   4      //                                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2470   4      //                                                      }
2471   4      //                                                      else
2472   4      //                                                      {
2473   4      //                                                                      break;
2474   4      //                                                      }
2475   4      //                              }break;                 
2476   4                                      
2477   4      //                              case 0x26:///è¯»è“ç‰™é…å¯¹å¯†ç   FE FE FE FE 68 A0 A1 A2 A3 A4 A5 A6 68 1E 09 32 32 32 32 59 33 3
             -3 33 33 cs 16
2478   4      //                              {
2479   4      //                                                      if(0x09!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
2480   4      //                                                      {
2481   4      //                                                                      break;
2482   4      //                                                      }               
2483   4      //                                                      if(_SUCCESS==BleDrv_GetBlePSK(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]))
2484   4      //                                                      {
2485   4      //                                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x06;
2486   4      //                                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2487   4      //                                                      }
2488   4      //                                                      else
2489   4      //                                                      {
2490   4      //                                                                      break;
2491   4      //                                                      }
2492   4      //                              }break;         
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 45  

2493   4      
2494   4      //                              case 0x27:///è®¾ç½®è“ç‰™é…å¯¹å¯†ç   FE FE FE FE 68 A0 A1 A2 A3 A4 A5 A6 68 1E 0B 32 32 32 32 59 3
             -3 33 33 33 33 33 cs 16
2495   4      //                              {
2496   4      //                                                      if(0x0B!=Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])
2497   4      //                                                      {
2498   4      //                                                                      break;
2499   4      //                                                      }               
2500   4      //                                                      LibPub_Inverse( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5], 6 );
2501   4      //                                                      if(_SUCCESS==BleDrv_SetBlePSK(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5]))
2502   4      //                                                      {
2503   4      //                                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0x00;
2504   4      //                                                                      V_ucErrorType = API_DLT645_COMM_ERR_OK;
2505   4      //                                                      }
2506   4      //                                                      else
2507   4      //                                                      {
2508   4      //                                                                      break;
2509   4      //                                                      }
2510   4      //                              }break; 
2511   4      
2512   4                                      ///* FE FE FE FE  68 AA AA AA AA AA AA 68 1E Len 32 32 32 32 B4 Type data1 data2 data3 CS 16 *///
2513   4                                      ///* Type:0x80ï¼šè¯»   0x00: å†™ *///
2514   4                                      case 0x81:
2515   4                                      {
2516   5                                              if(  Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5] == 0x00 )              ///* å†™ *///
2517   5                                              {
2518   6                                                      V_ucErrorType = API_DLT645_COMM_ERR_NOAUTH;
2519   6                                                      if ( GStr_Flag.ucMeterMode & F_FACTORY_MODE )///* å‚å†…å¯å†™ *///
2520   6                                                      {
2521   7                                                              if ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] == 0x14 )
2522   7                                                              {
2523   8                                                                      if ( _SUCCESS == LibPub_WriteDataToE2prom( LIB_E2P_FUN_CONFIG, 0, &Gstr_UartComm[v_ucChID].ucaComm
             -TXBuff[API_DLT645_1STDATA+6]) )
2524   8                                                                      {
2525   9                                                                              LibPub_MemCopyBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+6], &GStr_FunConfi
             -gPara.ucFunCurrentVal, GStr_FUN_CONFIG_TypeLEN );
2526   9                                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;                                      
2527   9                                                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2528   9                                                                      }
2529   8                                                              }
2530   7                                                      }
2531   6                                              }
2532   5                                              else if(  Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+5] == 0x80 ) ///* è¯» *///
2533   5                                              {
2534   6                                                      if( _SUCCESS == LibPub_ReadDataFromE2prom( LIB_E2P_FUN_CONFIG, 0, &Gstr_UartComm[v_ucChID].ucaCommTX
             -Buff[API_DLT645_D0_R] ) )
2535   6                                                      {
2536   7                                                              LibPub_MemCopyBytes( &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], &GStr_FunConfigPara.u
             -cFunCurrentVal, GStr_FUN_CONFIG_TypeLEN );
2537   7                                                              
2538   7                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 4+14;
2539   7                                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2540   7                                                      }
2541   6                                              }
2542   5                                              else
2543   5                                              {
2544   6                                                      break;
2545   6                                              }
2546   5                                      }break;
2547   4      
2548   4                                      default:break;
2549   4                              }
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 46  

2550   3                      }
2551   2              }
2552   1              else    ///* æ§åˆ¶ç ä¸º1F *///
2553   1              { 
2554   2                              switch ( Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA] )
2555   2                              {
2556   3                                              case 0x13:///* ç”µè¡¨åˆå§‹åŒ–ï¼šFE FE FE 68 AA AA AA AA AA AA 68 1F 04 46 47 87 B3 B6 16 *///
2557   3                                              {
2558   4                                                              V_ucErrorType = API_DLT645_COMM_ERR_NOAUTH;
2559   4                                                              if ( GStr_Flag.ucMeterMode & F_FACTORY_MODE )///* å‚å†…å¯å†™ *///
2560   4                                                              {
2561   5                                                                              if( V_ulDI3DI2DI1DI0 == 0x80541413 )
2562   5                                                                              {
2563   6                                                                                              ApiPwOn_MeterInitInFactory();
2564   6                                                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 0;
2565   6                                                                                              V_ucErrorType = API_DLT645_COMM_ERR_OK;
2566   6                                                                              }
2567   5                                                              }
2568   4                                                      
2569   4                                              }break;
2570   3                                              
2571   3                                              default:break;
2572   3                                      
2573   3                              }
2574   2              }
2575   1                      
2576   1              return V_ucErrorType;
2577   1      }
2578          
2579          
2580          ///**********************************************************************///
2581          ///* Brief: èº«ä»½è®¤è¯                                                  *///
2582          ///*                                                                    *///
2583          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
2584          ///*                                                                    *///
2585          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
2586          ///*                                                                    *///
2587          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
2588          ///**********************************************************************///
2589          uchar8 ApiDLT645_SafeCertification(uchar8 v_ucChID)
2590          {
2591   1              uchar8  i,j;
2592   1              uchar8  V_ucDI[4];
2593   1              uchar8  V_ucErrorType;
2594   1              ulong32 V_ulDI0DI1DI2DI3;
2595   1              // uchar8       V_Temp,V_Temp1;
2596   1              // ushort16     V_usStateFlag3;
2597   1              // uchar8       V_ucTempData[60];
2598   1      
2599   1              V_ucErrorType = API_DLT645_COMM_ERR_NOACK;
2600   1              GU_SecurityErr.BYTE[0] = 0x00;
2601   1              GU_SecurityErr.BYTE[1] = 0x00;
2602   1              V_ulDI0DI1DI2DI3 = 0;
2603   1      
2604   1          LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0],&GA_ucDICode[0],4);///æ•°æ
             -®æ ‡è¯†
2605   1              LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0],&GA_ucOperCode[0],4);///æ“ä½œ
             -è€…ä»£ç 
2606   1              if  (Gstr_UartComm[v_ucChID].ucCommAddrType == F_COMMADDRTYPE_ID)       /* å…¨åœ°å€ç›¸ç­‰æ‰å¯ä»¥æ“ä½œ */
2607   1              {  
2608   2                      if (GStr_Flag.ucRunState2&F_RUN_INTAUTH_MACNumErrFlag )         ///*å®‰å…¨è®¤è¯æ ‡è¯†æŒ‚èµ·å°±ä¸å…è®¸æ‰§è¡Œä
             -º†*///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 47  

2609   2                      {
2610   3                              *((ushort16 *)(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]) )= 0x0001;///*å®‰å…¨è®¤è¯é”
             -™è¯¯*///
2611   3                              V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2612   3                      }
2613   2                      else
2614   2                      {
2615   3                              for ( i = 0; i < 4; i++ )
2616   3                              {
2617   4                                      V_ucDI[i] = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+i];
2618   4                                      V_ulDI0DI1DI2DI3 |= (((ulong32)V_ucDI[i])<<(8*i));
2619   4                              }
2620   3                              
2621   3                              for ( j = 0; j < C_SafeCertifiificationCodeNum; j++ )
2622   3                              {
2623   4                                      if ( V_ulDI0DI1DI2DI3 == C_ulaSafeCertification_Code[j] )///* æŸ¥è¡¨æ‰¾ç›¸åº”çš„æ•°æ®æ ‡è¯† *///
2624   4                                      {
2625   5                                              if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN])!=C_ulaSafeCertification_Len[j])
2626   5                                              {
2627   6                                                      *((ushort16 *)(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA])) = 0x0100;
2628   6                                                      V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2629   6                                                      break;
2630   6                                              }
2631   5                                              else
2632   5                                              {
2633   6                                                      ///* å®šä¹‰çš„å‡½æ•°å‚æ•°å’Œä¼ é€’çš„å‚æ•°ä¸åŒ¹é…ï¼Œä¿®æ”¹åå€¼ä¼ é€’ä»DI0å¼€å§‹çš„æ•°æ® *///
2634   6                                                      switch ( j )
2635   6                                                      {
2636   7                                                              case 0:         ///èº«ä»½è®¤è¯
2637   7                                                              { 
2638   8                                                                      V_ucErrorType = PrepaymentModule_Comm_INTAUTH(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI
             -0]); 
2639   8                                                              }break;
2640   7                                                              
2641   7                                                              case 1:         ///èº«ä»½è®¤è¯æ—¶æ•ˆè®¾ç½®
2642   7                                                              {
2643   8                                                                      V_ucErrorType = PrepaymentModule_Comm_TimeAvailableIn(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_D
             -LT645_DI0]); 
2644   8                                                              }break;
2645   7                                                              
2646   7                                                              case 2:         ///* å¼€æˆ· *///
2647   7                                                              case 3:         ///* å……å€¼ *///
2648   7                                                              case 4:         ///* é’±åŒ…åˆå§‹åŒ– */// 
2649   7                                                              // case 5:              ///* è¡¥åŠ©é‡‘é¢å……å€¼ *///
2650   7                                                              {
2651   8                                                                      V_ucErrorType = PrepaymentModule_Comm_OpenAccout(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645
             -_DI0]);  
2652   8                                                              }break;
2653   7                                                              
2654   7                                                          case 5:             ///* å¯†é’¥æ›´æ–° *///
2655   7                                                              {
2656   8                                                                      V_ucErrorType = PrepaymentModule_Comm_ModifyKey(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_
             -DI0]); 
2657   8                                                              }break; 
2658   7                                                              
2659   7                                                              
2660   7                                                              case 6:         ///* èº«ä»½è®¤è¯å¤±æ•ˆ *///
2661   7                                                              {
2662   8                                                                      V_ucErrorType = PrepaymentModule_Comm_INTAUTH_Invalidation(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[
             -API_DLT645_DI0]);
2663   8                                                              }break;
2664   7                                                              
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 48  

2665   7                                                              default:  break;                   
2666   7                                                      }
2667   6                                                      if( C_ERR == V_ucErrorType)
2668   6                                                      {
2669   7                                                              V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2670   7                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]= GU_SecurityErr.BYTE[0];
2671   7                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+1]= GU_SecurityErr.BYTE[1];                       ///*é”™è¯
             -¯è¿”å›é”™è¯¯ä¿¡æ¯å­—*///
2672   7                                                              break;
2673   7                                                      }
2674   6                                                      else
2675   6                                                      {
2676   7                                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = C_ulaSafeCertification_ReturnLen[j];                                                    
             -        
2677   7                                                              V_ucErrorType = C_ulaSafeCertification_ReturnType[j];
2678   7                                                      }
2679   6                                                      break;
2680   6                                              }
2681   5                                      }
2682   4                              }
2683   3                              if(j >=C_SafeCertifiificationCodeNum)
2684   3                              {
2685   4                                      *((ushort16 *)(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA])) = 0x0100;
2686   4                                      V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2687   4                              }
2688   3                      }
2689   2              }
2690   1              else
2691   1              {
2692   2                      V_ucErrorType = 0x80;
2693   2              }
2694   1      
2695   1              return(V_ucErrorType);
2696   1              
2697   1      }
2698          ///**********************************************************************///
2699          ///* Brief: ç”µè¡¨æ¸…é›¶                                                    *///
2700          ///*                                                                    *///
2701          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
2702          ///*                                                                    *///
2703          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
2704          ///*                                                                    *///
2705          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
2706          ///**********************************************************************///
2707          uchar8 ApiDLT645_MeterClear( uchar8 v_ucChID )////è¯¥å‘½ä»¤åªåœ¨å‚å†…æœ‰æ•ˆï¼Œéœ€éªŒè¯00çº§å¯†ç ï¼Œå¯†
             -ç 000000
2708          {
2709   1              
2710   1              if  (Gstr_UartComm[v_ucChID].ucCommAddrType != F_COMMADDRTYPE_ID)       /* å…¨åœ°å€ç›¸ç­‰æ‰å¯ä»¥æ“ä½œ */
2711   1              {
2712   2                              return API_DLT645_COMM_ERR_NODATA;    //0x02    ///* æ— è¯·æ±‚æ•°æ® *///
2713   2              }
2714   1              if  (Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] != 0x08)     /* é•¿åº¦éœ€ä¸º8 */
2715   1              {
2716   2                              return API_DLT645_COMM_ERR_OTHER;     //0x01    ///* å…¶ä»–é”™è¯¯ *///
2717   2              }
2718   1              if(GStr_Flag.ucMeterMode&F_FACTORY_MODE)
2719   1              {
2720   2                      if(0x00==Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA])
2721   2                      {
2722   3                              if(_FAILED==LibPub_CheckPassword(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]))
2723   3                              {
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 49  

2724   4                                      return API_DLT645_COMM_ERR_NOAUTH;
2725   4                              }       
2726   3                      }
2727   2                      else
2728   2                      {
2729   3                              return API_DLT645_COMM_ERR_NOAUTH;
2730   3                      }
2731   2              }
2732   1              else
2733   1              {
2734   2                              return API_DLT645_COMM_ERR_NOAUTH;      
2735   2              }
2736   1              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]=0;
2737   1              ApiPwOn_MeterClear();   
2738   1              ApiRelay_SubtractMoneyRelayJudge();///æ€»æ¸…å®Œå¤„ç†ä¸€ä¸‹ç»§ç”µå™¨
2739   1              ApiRelay_ControlProcess();
2740   1              // GV_ClearFlag=CommClear;
2741   1              return API_DLT645_COMM_ERR_OK;
2742   1      }
2743          
2744          ///**********************************************************************///
2745          ///* Brief: ç³»ç»Ÿè‡ªæ‰©å‘½ä»¤ï¼ˆå……å€¼ã€èº«ä»½è®¤è¯ï¼‰                            *///
2746          ///*                                                                    *///
2747          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
2748          ///*                                                                    *///
2749          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
2750          ///*                                                                    *///
2751          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
2752          ///**********************************************************************///
2753          uchar8 ApiDLT645_AccountTx(uchar8  v_ucChID )
2754          {
2755   1              uchar8  i;
2756   1              uchar8  V_ucDI[4];
2757   1              uchar8  V_ucErrorType;
2758   1              ulong32 V_ulDI0DI1DI2DI3;
2759   1              uchar8  V_Temp,V_Temp1;
2760   1              ushort16        V_usStateFlag3;
2761   1              uchar8  V_ucTempData[35];
2762   1      
2763   1              V_ucErrorType = API_DLT645_COMM_ERR_NOACK;
2764   1              GU_SecurityErr.BYTE[0] = 0x00;
2765   1              GU_SecurityErr.BYTE[1] = 0x00;
2766   1              V_ulDI0DI1DI2DI3 = 0;
2767   1      
2768   1              if( BLE_STAT_CONNECTED != GStr_Flag.ucBLESTATFlag)              ///*ç©ºé—²çŠ¶æ€*///
2769   1              {
2770   2                      return(API_DLT645_COMM_ERR_NOACK);              ///*ç©ºé—²çŠ¶æ€ä¸åº”ç­”*///
2771   2              }
2772   1      
2773   1          LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0],&GA_ucDICode[0],4);///æ•°æ
             -®æ ‡è¯†
2774   1              LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_PA0],&GA_ucOperCode[0],4);///æ“ä½œ
             -è€…ä»£ç 
2775   1              if  (Gstr_UartComm[v_ucChID].ucCommAddrType == F_COMMADDRTYPE_ID)       /* å…¨åœ°å€ç›¸ç­‰æ‰å¯ä»¥æ“ä½œ */
2776   1              {  
2777   2                      if (GStr_Flag.ucRunState2&F_RUN_INTAUTH_MACNumErrFlag )         ///*å®‰å…¨è®¤è¯æ ‡è¯†æŒ‚èµ·å°±ä¸å…è®¸æ‰§è¡Œä
             -º†*///
2778   2                      {
2779   3                              *((ushort16 *)(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]) )= 0x0001;///*å®‰å…¨è®¤è¯é”
             -™è¯¯*///
2780   3                              V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2781   3                      }
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 50  

2782   2                      else
2783   2                      {
2784   3                              for ( i = 0; i < 4; i++ )
2785   3                              {
2786   4                                      V_ucDI[i] = Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+i];
2787   4                                      V_ulDI0DI1DI2DI3 |= (((ulong32)V_ucDI[i])<<(8*i));
2788   4                              }
2789   3                              if( 0x070000EE == V_ulDI0DI1DI2DI3)     ///èº«ä»½è®¤è¯(è‡ªæ‰©æ•°æ®æ ‡è¯†ï¼Œè“ç‰™èº«ä»½è®¤è¯è¿”å›ä¿¡æ¯
             -)
2790   3                              {
2791   4                                      if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]) != 32)
2792   4                                      {
2793   5                                              *((ushort16 *)(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA])) = 0x0100;
2794   5                                              V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2795   5                                      }
2796   4                                      else
2797   4                                      {
2798   5                                              V_ucErrorType = PrepaymentModule_Comm_INTAUTH(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0])
             -; 
2799   5                                              if( V_ucErrorType == C_OK)      ///*èº«ä»½è®¤è¯æˆåŠŸ*///
2800   5                                              {
2801   6                                                      ///ä¸Šä¸€æ¬¡è´­ç”µè®°å½•
2802   6                                                      V_Temp=GStr_EventValidPiont.uc_Point[C_BuyMoney];///ä¸Šä¸€æ¬¡è´­ç”µè®°å½•çš„æŒ‡é’ˆ
2803   6                                                      V_Temp1=CAddr_SelfMoney_Lenth;///ä¸Šä¸€æ¬¡è´­ç”µè®°å½•çš„é•¿åº¦
2804   6                                                      Hal_ReadEEPROM(V_ucTempData,CAddr_SelfMoney_Note+V_Temp*V_Temp1,V_Temp1);////è¯»å–è´­ç”µè®°å½•
2805   6                                                      LibPub_Inverse( &V_ucTempData[0], 2 );///ä¸Šä¸€æ¬¡è´­ç”µåè´­ç”µæ€»æ¬¡æ•°
2806   6                                                      LibPub_Inverse( &V_ucTempData[2], 4 );///ä¸Šä¸€æ¬¡è´­ç”µé‡‘é¢
2807   6                                                      LibPub_Inverse( &V_ucTempData[6], 4 );///ä¸Šä¸€æ¬¡è´­ç”µå‰å‰©ä½™é‡‘é¢
2808   6                                                      LibPub_Inverse( &V_ucTempData[10], 4 );///ä¸Šä¸€æ¬¡è´­ç”µåå‰©ä½™é‡‘é¢
2809   6                                                      LibPub_Inverse( &V_ucTempData[14], 4 );///ä¸Šä¸€æ¬¡è´­ç”µåæ€»è´­ç”µé‡‘é¢               
2810   6      
2811   6                                                      ///è¡¨å†…å‰©ä½™é‡‘é¢
2812   6                                                      LibPub_MemExchangeBytes(&GStr_Money.ucaRemainMoney[0], &V_ucTempData[18], 0x04 );       
2813   6                      
2814   6                                                      ///è¡¨å†…é€æ”¯é‡‘é¢
2815   6                                                      LibPub_MemExchangeBytes(GStr_Money.ucaTickMoney, &V_ucTempData[22], 0x04 );     
2816   6      
2817   6                                                      ///åˆé—¸å…è®¸é‡‘é¢
2818   6                                                      LibPub_MemExchangeBytes(GStr_MoneyPara.ucaAllowcloseMoney, &V_ucTempData[26], 0x04 );
2819   6      
2820   6                                                      ///å›¤ç§¯é‡‘é¢é™å€¼
2821   6                                                      LibPub_MemExchangeBytes(GStr_MoneyPara.ucaMaxMoneyLimit, &V_ucTempData[30], 0x04 );     
2822   6                                                      
2823   6                                                      ///å½“å‰æ€»ç”µé‡
2824   6                                                      LibPub_MemExchangeBytes(&GStr_Energy.ucaFw_Energy[0], &V_ucTempData[34], 0x04 );                        
2825   6      
2826   6                                                      ///çŠ¶æ€å­—3
2827   6                                                      V_usStateFlag3=ApiDLT645_GetStatusFlag3();
2828   6                                                      V_ucTempData[38] = (uchar8)V_usStateFlag3;
2829   6                                                      V_ucTempData[39] = (uchar8)(V_usStateFlag3>>8);
2830   6                                                      GStr_Flag.ucRunState3|=F_RUN_READ_RANDOM2;///ç½®è¯»å–éšæœºæ•°æ ‡å¿—.
2831   6                                                      GStr_Monitor.ulReadRandom2DelayTime = LibPub_GetTimerBeat();///è¯»éšæœºæ•°2åå–ç³»ç»Ÿæ—¶é—´
2832   6                                                      ///ç½®äº”åˆ†é’Ÿ 
2833   6                                                      LibPub_MemCopyBytes( V_ucTempData, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+16], 40
             -);        
2834   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 40+16;
2835   6                                                      V_ucErrorType = 0x11;
2836   6                                              }
2837   5                                              else
2838   5                                              {
2839   6                                                      V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2840   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA]= GU_SecurityErr.BYTE[0];
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 51  

2841   6                                                      Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_1STDATA+1]= GU_SecurityErr.BYTE[1];    ///*é”™è¯¯è¿”å›
             -é”™è¯¯ä¿¡æ¯å­—*///
2842   6                                              }
2843   5                                      }
2844   4                              }
2845   3                              else if( 0x070102EE == V_ulDI0DI1DI2DI3)        ///å……å€¼(è‡ªæ‰©æ•°æ®æ ‡è¯†ï¼Œè“ç‰™å……å€¼è¿”å›ä¿¡æ¯)
2846   3                              {
2847   4                                      if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]) != 30)
2848   4                                      {
2849   5                                              *((ushort16 *)(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R])) = 0x0100;
2850   5                                              V_ucErrorType = API_DLT645_SAFE_CERT_ERR;
2851   5                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 6;///*è¿”å›æ•°æ®çš„é•¿åº¦ï¼ŒåŒ…å«äº†4ä¸ªå­
             -—èŠ‚çš„æ ‡è¯†ç *///                                                  
2852   5                                      }
2853   4                                      else
2854   4                                      {
2855   5                                              V_ucErrorType = PrepaymentModule_Comm_OpenAccout(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI
             -0]);  
2856   5                                              V_ucTempData[0] = V_ucErrorType;
2857   5                                              V_ucTempData[1] = 0x00;
2858   5                                              ///å½“å‰æ€»ç”µé‡4å­—èŠ‚ 
2859   5                                              LibPub_MemExchangeBytes(&GStr_Energy.ucaFw_Energy[0], &V_ucTempData[2], 0x04 );
2860   5      
2861   5                                              ///æ€»è´­ç”µé‡‘é¢4å­—èŠ‚
2862   5                                              LibPub_MemExchangeBytes(&GStr_PRICE.ucaPurchaseMoneyAll[0], &V_ucTempData[6], 0x04 );
2863   5      
2864   5                                              ///è´­ç”µæ¬¡æ•°4å­—èŠ‚
2865   5                                              LibPub_MemExchangeBytes(&GStr_PRICE.ucPurchaseTimes[0], &V_ucTempData[10], 0x04 );
2866   5      
2867   5                                              ///è¡¨å†…å‰©ä½™é‡‘é¢4å­—èŠ‚
2868   5                                              LibPub_MemExchangeBytes(&GStr_Money.ucaRemainMoney[0], &V_ucTempData[14], 0x04 );
2869   5      
2870   5                                              ///è¡¨å†…é€æ”¯é‡‘é¢4å­—èŠ‚
2871   5                                              LibPub_MemExchangeBytes(GStr_Money.ucaTickMoney, &V_ucTempData[18], 0x04 );
2872   5      
2873   5                                              ///çŠ¶æ€å­—3 2å­—èŠ‚
2874   5                                              //V_usStateFlag3=ApiDLT645_GetStatusFlag3();
2875   5                                              V_ucTempData[22]=(uchar8)ApiDLT645_GetStatusFlag3();
2876   5                                              V_ucTempData[23]=(uchar8)(ApiDLT645_GetStatusFlag3()>>8);
2877   5      
2878   5                                              LibPub_MemCopyBytes( V_ucTempData, &Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_D0_R], 24);        
2879   5      
2880   5                                              Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN] = 28;///*è¿”å›æ•°æ®çš„é•¿åº¦ï¼ŒåŒ…å«äº†4ä¸ªå
             -­—èŠ‚çš„æ ‡è¯†ç *///                                                 
2881   5                                      }                       
2882   4                              }
2883   3                      }
2884   2              }
2885   1              else
2886   1              {
2887   2                      V_ucErrorType = 0x80;
2888   2              }
2889   1              return(V_ucErrorType);
2890   1      }
2891          
2892          
2893          ///**********************************************************************///
2894          ///* Brief: ä¿®æ”¹å¯†ç                                               *///
2895          ///*                                                                    *///
2896          ///* Param:  v_ucChIDï¼šé€šé“                                             */// 
2897          ///*                                                                    *///
2898          ///* Return: è¿”å›å¤„ç†ç»“æœ                                                                 *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 52  

2899          ///*                                                                    *///
2900          ///* Note:   ä¿®æ”¹åŠå…¶ä»–è¯´æ˜                                              *///
2901          ///**********************************************************************///
2902          uchar8 ApiDLT645_ModifyPsw(uchar8  v_ucChID )
2903          {
2904   1              uchar8  V_ucErrorType;
2905   1              uchar8  i,V_ucTempBuff[11];
2906   1              uchar8  V_ucaPasswordDI0[3]={0x01,0x02,0x03};   ///*åªæ”¯æŒä¿®æ”¹00ã€01ã€02*///
2907   1              V_ucErrorType = API_DLT645_COMM_ERR_NOAUTH;
2908   1      
2909   1              if  (Gstr_UartComm[v_ucChID].ucCommAddrType == F_COMMADDRTYPE_ID)       /* å…¨åœ°å€ç›¸ç­‰æ‰å¯ä»¥æ“ä½œ */
2910   1              {
2911   2                              if( (Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_LEN]== 12)&&(LibPub_CheckPassword(&(Gstr_UartComm
             -[v_ucChID].ucaCommTXBuff[API_DLT645_PA0]))==_SUCCESS) ) 
2912   2                              {
2913   3                                              if((Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+3]==0x04)&&(Gstr_UartComm[v_ucChID].ucaCommT
             -XBuff[API_DLT645_DI0+2]==0x00)&&(Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0+1]==0x0c))
2914   3                                              {
2915   4                                                              for(i=0;i<3;i++)
2916   4                                                              {
2917   5                                                                              if(Gstr_UartComm[v_ucChID].ucaCommTXBuff[API_DLT645_DI0]==V_ucaPasswordDI0[i])
2918   5                                                                              {
2919   6                                                                                              if( (Gstr_UartComm[v_ucChID].ucaCommTXBuff[22]==(V_ucaPasswordDI0[i])-1) && (Gstr_UartComm[v_uc
             -ChID].ucaCommTXBuff[API_DLT645_PA0]<=(V_ucaPasswordDI0[i])-1) )
2920   6                                                                                              {
2921   7                                                                                                              if(_SUCCESS==LibPub_ReadDataFromE2prom(LIB_E2P_Password, 0, V_ucTempBuff))
2922   7                                                                                                              {
2923   8                                                                                                                              LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[23], &V_ucTempBuff[i*3], 3);
2924   8                                                                                                                      
2925   8                                                                                                                              if(_SUCCESS==LibPub_WriteDataToE2prom(LIB_E2P_Password,0,  V_ucTempBuff))
2926   8                                                                                                                              {
2927   9                                                                                                                                              LibPub_MemCopyBytes(&Gstr_UartComm[v_ucChID].ucaCommTXBuff[22],&Gstr_UartComm[v_ucChID].u
             -caCommTXBuff[14],4);
2928   9                                                                                                                                              V_ucErrorType=API_DLT645_COMM_WR_OK;
2929   9                                                                                                                              }
2930   8                                                                                                      } 
2931   7                                                                                      }
2932   6                                                                                      break;
2933   6                                                                      }
2934   5                                                              }
2935   4                                              }
2936   3                              }
2937   2              }
2938   1              else
2939   1              {
2940   2                              V_ucErrorType = API_DLT645_COMM_ERR_NOACK;
2941   2              }
2942   1      
2943   1              return(V_ucErrorType);
2944   1      }
2945          
2946          
2947          ///**********************************************************************///
2948          ///* Brief: è·å–çŠ¶æ€å­—3      åªæ”¯æŒBIT15å¼€æˆ·çŠ¶æ€ã€ BIt13èº«ä»½è®¤è¯æœ‰æ•ˆã€BIT12ä¿ç”µ        
             -                                   *///
2949          ///*                            BIT9BIT8ç”µè¡¨ç±»å‹ã€bit6ç»§ç”µå™¨å‘½ä»¤çŠ¶æ€ã€                       
             -                 *///
2950          ///* Param:                                        */// 
2951          ///*                                                                    *///
2952          ///* Return:                                                            *///
2953          ///*                                                                    *///
2954          ///* Note:                                               *///
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 53  

2955          ///**********************************************************************///
2956          ushort16 ApiDLT645_GetStatusFlag3(void)
2957          {
2958   1              ushort16 V_usResult=0;
2959   1              /*æœªå¼€æˆ·*/
2960   1              if(!(GStr_Flag.ucRunState2&F_RUN_OpenAccoutFlag))
2961   1              {
2962   2                      V_usResult|=_BIT15;  ///æœªå¼€æˆ·çŠ¶æ€ç½®1
2963   2              }
2964   1              /*èº«ä»½è®¤è¯æœ‰æ•ˆ*/
2965   1              if(GStr_Flag.ucRunState2&F_RUN_INTAUTHAvailabilityFlag)
2966   1              {
2967   2                      V_usResult|=_BIT13;  ///èº«ä»½è®¤è¯æœ‰æ•ˆç½®1
2968   2              }
2969   1              /*ä¿ç”µ*/
2970   1              if(GStr_Flag.ucRunState&F_RUN_KEEP_ELEC)
2971   1              {
2972   2                      V_usResult|=_BIT12;  ///ä¿ç”µç½®1
2973   2              }
2974   1              /*ä¸€çº§æŠ¥è­¦*/
2975   1              if(GStr_Flag.ucRunState1&F_RUN_L1_ALRAM)        
2976   1              {
2977   2                      V_usResult|=_BIT11;             /*ä¸€çº§æŠ¥è­¦ç½®1*/
2978   2              }
2979   1              /*äºŒçº§æŠ¥è­¦*/
2980   1              if(GStr_Flag.ucRunState1&F_RUN_L2_ALRAM)
2981   1              {
2982   2                      V_usResult|=_BIT10;             /*äºŒçº§æŠ¥è­¦ç½®1*/
2983   2              }
2984   1              
2985   1              V_usResult|=_BIT9;  ///BIT9ã€BIt8ä¸º10  ç”µè´¹å‹é¢„ä»˜è´¹è¡¨
2986   1              
2987   1              /*ç»§ç”µå™¨çŠ¶æ€ä¸ºè·³é—¸çŠ¶æ€*/
2988   1              if(GStr_Flag.ucRunState2&F_RUN_RELAY_STATE)
2989   1              {
2990   2                      V_usResult|=_BIT4;  ///è·³é—¸ç½®1
2991   2              }
2992   1              /*å¯†é’¥çŠ¶æ€ä¸ºç§é’¥*/
2993   1              if(GStr_Flag.ucRunState2&F_RUN_EsamKeyFlag)
2994   1              {
2995   2                      V_usResult|=_BIT3;  ///ç§é’¥ç½®1
2996   2              }
2997   1              /*é€æ”¯è¶…é€æ”¯é—¨é™*/
2998   1              if(GStr_Flag.ucRunState&F_RUN_OVER_DRAFTRELAY)
2999   1              {
3000   2                      V_usResult|=_BIT2;  ///é€æ”¯è¶…é€æ”¯é—¨é™ç½®1
3001   2              }
3002   1              /*é€šä¿¡è·³é—¸*/
3003   1              if(GStr_Flag.ucRunState&F_RUN_COMM_RELAYOFF)
3004   1              {
3005   2                      V_usResult|=_BIT1;  ///è·³é—¸ç½®1
3006   2              }
3007   1              
3008   1                return V_usResult;
3009   1      }
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 54  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


C_cBleComm_Head. . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0022H  17
uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
IB_CON2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F3H  1
COMM_BLE_STAT. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
API_COMM_STATUS_OVERTIME . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
IB_CON3. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F4H  1
FP64 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
TKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
IB_CON4. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F5H  1
PASLO. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E7H  1
GT_ucaFactoryVerNo . . . . . . . . . .  PUBLIC   CODE   ARRAY    0000H  8
GStr_ENERGYDEC_Type. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  26
  ucaFw_EnergyDec. . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  13
  ucaBk_EnergyDec. . . . . . . . . . .  MEMBER   -----  ARRAY    000DH  13
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
OSCLO. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FEH  1
IB_CON5. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F6H  1
_LibPub_Inverse. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_EventRecordNum_Type . . . . . . .  TYPEDEF  -----  STRUCT   -----  26
  ucEventTimes . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  24
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0018H  2
GStr_FLAG_Type . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  16
  ucSystem . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ucMeterMode. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  ucPwOnState. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ucRunState . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
  ucRunState2. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  ucRunState1. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  ucRunState3. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  ucDisp . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
  ucFactoryKey . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
  ucDispKey. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000BH  1
  ucMoney. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000CH  1
  ucPowerOnFlag. . . . . . . . . . . .  MEMBER   -----  U_CHAR   000DH  1
  ucWrE2promSafeByte . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  ucBLESTATFlag. . . . . . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
BOOLEAN. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
SM1_RXOV . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
SPCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A1H  1
SBRTH. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009CH  1
P5 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E9H  1
_ApiDLT645_AddrTypeCheck . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  j. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
  V_ucAddrType . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
Comm_MAP_TAB . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0033H  546
GU_SecurityErr . . . . . . . . . . . .  PUBLIC   XDATA  UNION    0000H  2
LIB_E2P_Price_BAK. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 55  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EAH  1
_PrepaymentModule_Comm_INTAUTH . . . .  EXTERN   CODE   PROC     -----  -----
LIB_E2P_Display_Table. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_DISPLAY_PARA_Type . . . . . . . .  TYPEDEF  -----  STRUCT   -----  129
  ucFullDisp_Time. . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ucDispDurTime. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  ucAutoDispNum. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ucKeyDispNum . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  usDisp_ParaCRC16 . . . . . . . . . .  MEMBER   -----  U_INT    0004H  2
  ucAutoDisptable. . . . . . . . . . .  MEMBER   -----  ARRAY    0006H  30
  ucKeyDisptable . . . . . . . . . . .  MEMBER   -----  ARRAY    0024H  30
  usDisp_tableCRC16. . . . . . . . . .  MEMBER   -----  U_INT    0042H  2
  ucBackLightTime. . . . . . . . . . .  MEMBER   -----  U_CHAR   0044H  1
  ucRelayLEDTime . . . . . . . . . . .  MEMBER   -----  U_CHAR   0045H  1
  ulDispUpdataTime . . . . . . . . . .  MEMBER   -----  U_LONG   0046H  4
  usDispCnt. . . . . . . . . . . . . .  MEMBER   -----  U_INT    004AH  2
  ulDisptimer. . . . . . . . . . . . .  MEMBER   -----  U_LONG   004CH  4
  ucKeydelaytimer. . . . . . . . . . .  MEMBER   -----  U_CHAR   0050H  1
  ucFirstKeyDisp . . . . . . . . . . .  MEMBER   -----  U_CHAR   0051H  1
  ucDisp_0_flag. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0052H  1
  ucDisp_tongxin_Flag. . . . . . . . .  MEMBER   -----  U_CHAR   0053H  1
  ucDisp_tongxin_Time. . . . . . . . .  MEMBER   -----  U_LONG   0054H  4
  ucDispNum. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0058H  1
  ucLCDDrvDispBuf. . . . . . . . . . .  MEMBER   -----  ARRAY    0059H  40
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
P7 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EBH  1
IB_DATA. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EFH  1
P8 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ECH  1
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
SBRTL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009DH  1
P9 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EDH  1
PBANKLO. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B7H  1
GStr_COUNTER_Type. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  ucFactoryMode_Cnt. . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  ucKeyRelayOn_Cnt . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  ucRelayDelay_Cnt . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  ucHoldMoney_Cnt. . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  ucPasswordErr_Cnt. . . . . . . . . .  MEMBER   -----  ARRAY    0006H  3
_ApiDLT645_WriteData . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  P_ucTemp . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0002H  64
  V_Temp . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0042H  1
  V_Temp1. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0043H  1
  V_ScreenNum. . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
  V_LcdNum . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0044H  1
  V_ulDI3DI2DI1DI0 . . . . . . . . . .  AUTO     XDATA  U_LONG   0045H  4
_PrepaymentModule_DataDecription . . .  EXTERN   CODE   PROC     -----  -----
SPSTA. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A2H  1
IEN0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
PWRCON1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B3H  1
ulong32. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
EMUSR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0095H  1
IEN1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
PWRCON2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B4H  1
DPH1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0085H  1
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 56  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P0_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0080H  1
ushort16 . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
P1_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P0_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0081H  1
ADCH . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C3H  1
BLE_DRV_OPERATION_INDEX. . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
LIB_E2P_SOFTI_J. . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P2_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A0H  1
P1_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0091H  1
P0_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0082H  1
IPH0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
DPL1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0084H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
LIB_E2P_FUN_CONFIG_BAK . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_MONITOR_Tpye. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  59
  ulTimer_ms . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  ulTimer_ms_old . . . . . . . . . . .  MEMBER   -----  U_LONG   0004H  4
  ulTimerClrWDT. . . . . . . . . . . .  MEMBER   -----  U_LONG   0008H  4
  ulTimerMin . . . . . . . . . . . . .  MEMBER   -----  U_LONG   000CH  4
  ulTimer5ms . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0010H  4
  ucPowerOnTimer . . . . . . . . . . .  MEMBER   -----  U_CHAR   0014H  1
  ulTimers . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0015H  4
  ulUpDateUIPTime. . . . . . . . . . .  MEMBER   -----  U_LONG   0019H  4
  ulSoftI_JTime. . . . . . . . . . . .  MEMBER   -----  U_LONG   001DH  4
  usSoftI_JTimeCRC16 . . . . . . . . .  MEMBER   -----  U_INT    0021H  2
  usPasswordErrTime. . . . . . . . . .  MEMBER   -----  ARRAY    0023H  8
  ucCommSymbolTime . . . . . . . . . .  MEMBER   -----  U_CHAR   002BH  1
  ucPowerLimitNum. . . . . . . . . . .  MEMBER   -----  U_CHAR   002CH  1
  ulOverDemandCloseTime. . . . . . . .  MEMBER   -----  U_LONG   002DH  4
  ulProgEventDelayTime . . . . . . . .  MEMBER   -----  U_LONG   0031H  4
  ulReadRandom2DelayTime . . . . . . .  MEMBER   -----  U_LONG   0035H  4
  ucBleAdvCnt. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0039H  1
  ucBleConnectCnt. . . . . . . . . . .  MEMBER   -----  U_CHAR   003AH  1
P3_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B0H  1
P2_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A1H  1
P1_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P0_3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0083H  1
IPH1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
COMM_BLE_MAC . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P4_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
P3_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B1H  1
P2_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A2H  1
P1_3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0093H  1
P0_4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0084H  1
EXF0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
C_ulaSafeCertification_Code. . . . . .  PUBLIC   CODE   ARRAY    0255H  28
P4_1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
P3_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B2H  1
P2_3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A3H  1
P1_4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P0_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0085H  1
P4_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1
P3_3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B3H  1
P2_4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A4H  1
P1_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0095H  1
P0_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
EXF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 57  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TKF0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
IPL0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
LIB_E2P_ENRGY_BAK. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P4_3 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
P3_4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B4H  1
P2_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A5H  1
P1_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
P0_7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0087H  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
IPL1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
LIB_E2P_EventNum . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
long32 . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
P4_4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
P3_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B5H  1
P2_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A6H  1
P1_7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0097H  1
TK0H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
SUSLO. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
P4_5 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
P3_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B6H  1
P2_7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A7H  1
TK1H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
P4_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
P3_7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B7H  1
TK2H . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
LIB_E2P_Money_BAK. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
short16. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
P4_7 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
E7816. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
TK0L . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
_ApiMS_CalibrationMeterComm. . . . . .  EXTERN   CODE   PROC     -----  -----
API_COMM_STATUS_ERROR. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
EADR . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TK1L . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
TK2L . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E5H  1
SADEN1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DBH  1
SM10_FE1 . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
SADEN2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FBH  1
_ApiGet_Lcd_ID . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LIB_E2P_EMU_CALPARA. . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_ENERGY_PULSE_Type . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  ucPulseAdd . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ucPulseAddBusy . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  ucPulseStatu . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ucPulseDecimal . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  ucPulseDecSavePtr. . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  ucPulseDecSaveNoFF . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  ucaPulseRemain . . . . . . . . . . .  MEMBER   -----  ARRAY    0006H  2
PS0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
_ApiDLT645_AccountTx . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  V_ucDI . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0002H  4
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 58  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  V_ulDI0DI1DI2DI3 . . . . . . . . . .  AUTO     XDATA  U_LONG   0007H  4
  V_Temp . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  V_Temp1. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000BH  1
  V_usStateFlag3 . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  V_ucTempData . . . . . . . . . . . .  AUTO     XDATA  ARRAY    000CH  35
PT0L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
SADDR1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DAH  1
LIB_E2P_INDEX_MAX. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LIB_E2P_Display_Para . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
SM12_TXCOL1. . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
PT1L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
SADDR2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FAH  1
RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
_ApiDLT645_FactoryCommand. . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  V_ucTempdata . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  V_usAddress. . . . . . . . . . . . .  AUTO     XDATA  U_INT    0003H  2
  V_ulDI3DI2DI1DI0 . . . . . . . . . .  AUTO     XDATA  U_LONG   0005H  4
  V_ulTempData32 . . . . . . . . . . .  AUTO     XDATA  U_LONG   0009H  4
COMM_BLE_MOD . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_PrepaymentModule_GetChallenge . . . .  EXTERN   CODE   PROC     -----  -----
PT2L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
SP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0081H  1
LibPub_GetTimerBeatInt0. . . . . . . .  EXTERN   CODE   PROC     -----  -----
INT32S . . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
LIB_E2P_EventNumPiont. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LibPub_GetTimerBeatInt1. . . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_METER_IFO_Type. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  27
  ucaCommAddr. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  6
  ucaMeterID . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0006H  6
  ucaUserID. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    000CH  6
  ucVoltageTrans . . . . . . . . . . .  MEMBER   -----  ARRAY    0012H  3
  ucCurrentTrans . . . . . . . . . . .  MEMBER   -----  ARRAY    0015H  3
  ucBpsVal . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0018H  1
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0019H  2
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
_LibPub_1BCD_2_1HEX. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
INT32U . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
INT16S . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
_ApiDLT645_UARTReceiveDataJudge0 . . .  PUBLIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  v_ucData . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
_ApiDLT645_UARTReceiveDataJudge1 . . .  PUBLIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  v_ucData . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
_LibPub_IsBCD. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
INT16U . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
PX4L . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
C_T2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
SFINE2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DEH  1
_ApiDLT645_ModifyPsw . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  V_ucTempBuff . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0003H  11
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 59  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  V_ucaPasswordDI0 . . . . . . . . . .  AUTO     XDATA  ARRAY    000EH  3
_LibPub_WriteDataToE2prom. . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_BLE_GROUP_Type. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  26
  ucBleMAC . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  6
  ucBleName. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0006H  12
  ucBleKey . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0012H  3
  usAdvTime. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0015H  2
  ucBleTPL . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0017H  1
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0018H  2
COMM_BLE_MFV . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_UIPDisplay. . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  135
GStr_EventNumPiont_Type. . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  uc_Num . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  6
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0006H  2
IRCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ADH  1
IRCON2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AFH  1
GStr_Comm_MAP. . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  14
  ucaDataId. . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  ucaRamAdd. . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
  IsWrite. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  ucaE2pIndex. . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  ucaE2offset. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000AH  1
  ucaDataLen . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000BH  1
  IsBCD. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000CH  1
  EEIsHEX. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000DH  1
ApiPwOn_MeterInitInFactory . . . . . .  EXTERN   CODE   PROC     -----  -----
API_COMM_STATUS_IDLE . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Gstr_UartComm. . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  -----
EXCON1 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ABH  1
SBUF . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
EXCON2 . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00ACH  1
PCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0087H  1
B32_B08. . . . . . . . . . . . . . . .  * TAG *  -----  UNION    -----  4
  B08. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  B16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  B32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
AUXC . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
COMM_BLE_TPL . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_UART_COMM_Type. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  423
  ucCommChStatus . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ucCommRevStep. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  ucCommRevLen . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ucCommSndLen . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  ucCommSndCnt . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  ucCommAddrType . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  ucCommError. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  ulCommTimeInit . . . . . . . . . . .  MEMBER   -----  U_LONG   0007H  4
  ulCommRcvByteOverTime. . . . . . . .  MEMBER   -----  U_LONG   000BH  4
  ulCommSndByteOverTime. . . . . . . .  MEMBER   -----  U_LONG   000FH  4
  ulCommRspOverTime. . . . . . . . . .  MEMBER   -----  U_LONG   0013H  4
  ucaCommRXBuff. . . . . . . . . . . .  MEMBER   -----  ARRAY    0017H  200
  ucaCommTXBuff. . . . . . . . . . . .  MEMBER   -----  ARRAY    00DFH  200
GStr_ENERGY_Type . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  10
  ucaFw_Energy . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  ucaBk_Energy . . . . . . . . . . . .  MEMBER   -----  ARRAY    0004H  4
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
GU_B32_B08_Type. . . . . . . . . . . .  TYPEDEF  -----  UNION    -----  4
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 60  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  B08. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  B16. . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  B32. . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
TK0BASEH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D4H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
IENX . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AAH  1
IB_OFFSET. . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00EEH  1
TK1BASEH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D6H  1
SBRT1H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DCH  1
TK2BASEH . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DFH  1
SBRT2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FCH  1
_PrepaymentModule_Comm_TimeAvailableIn  EXTERN   CODE   PROC     -----  -----
C_ulaSafeCertification_Len . . . . . .  PUBLIC   CODE   ARRAY    0271H  7
RSTSTAT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B1H  1
LIB_E2P_Password . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TK0BASEL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
_ApiDLT645_FrameAnalysis . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucTemp . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  V_ucCnt_i. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  BLE_head_Frame . . . . . . . . . . .  AUTO     XDATA  ARRAY    0003H  20
LIB_E2P_BLE_PARA . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LIB_E2P_RUN_STATE. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TK1BASEL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D5H  1
SBRT1L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00DDH  1
COMM_BLE_TTP . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EMU_EPADR_Type . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  ucEmuAddr. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ulEmuRegData . . . . . . . . . . . .  MEMBER   -----  U_LONG   0001H  4
TK2BASEL . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D7H  1
SBRT2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00FDH  1
API_COMM_STATUS_SEND . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_LibPub_CRC16_CCITT. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SM0_FE . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
CLKCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
C_ulaSafeCertification_ReturnLen . . .  PUBLIC   CODE   ARRAY    0278H  7
API_COMM_STATUS_RECV_OK. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GT_ucaProtocolVer. . . . . . . . . . .  PUBLIC   CODE   ARRAY    0012H  16
SM2_TXCOL. . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
_Hal_ReadEEPROM. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
C_ulaSafeCertification_ReturnType. . .  PUBLIC   CODE   ARRAY    027FH  7
LDOCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B5H  1
B. . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F0H  1
API_COMM_STATUS_RECV . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EEPROM_MAP_TAB . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  -----
GStr_MeterIFO. . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  27
_?ix1000 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    02EEH  20
_?ix1001 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0302H  3
_ApiGet_Lcd_Num. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EMU_CALPARA_Type . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  22
  ulaCalPara . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  20
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0014H  2
GStr_DisplayPara . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  129
CP_RL2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
LIB_E2P_EMU_UIPKms . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 61  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


GStr_UIP_GROUP_Type. . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  68
  ulVoltage. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  16
  ulCurrent. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0010H  16
  ulPower. . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0020H  16
  ulFactory. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0030H  16
  ulFrequency. . . . . . . . . . . . .  MEMBER   -----  U_LONG   0040H  4
ApiRelay_ControlProcess. . . . . . . .  EXTERN   CODE   PROC     -----  -----
ENUM_API_COMM_STATUS . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
LibPub_GetTimerBeat. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_BLEGroup. . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  26
ACC. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E0H  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
_ApiDLT645_ReadEmuReg. . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
ApiRelay_SubtractMoneyRelayJudge . . .  EXTERN   CODE   PROC     -----  -----
GT_ucVirtualEsam . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0286H  104
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
_BleDrv_GetBleTPL. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
_ApiDLT645_ReadMeterAddress. . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D8H  1
RB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
TH0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008CH  1
INSCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0086H  1
GA_ucDICode. . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  4
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
uchar8 . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D9H  1
TB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
TH2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CDH  1
LIB_E2P_EMU_CALPARA_BAK. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_Monitor . . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  59
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
GStr_Energy. . . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  10
GStr_UIP_DISPLAY_Type. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  135
  ucVoltage. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  ucVoltageA . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0004H  4
  ucVoltageB . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0008H  4
  ucVoltageC . . . . . . . . . . . . .  MEMBER   -----  ARRAY    000CH  4
  ucCOMMVoltage. . . . . . . . . . . .  MEMBER   -----  ARRAY    0010H  4
  ucCOMMVoltageA . . . . . . . . . . .  MEMBER   -----  ARRAY    0014H  4
  ucCOMMVoltageB . . . . . . . . . . .  MEMBER   -----  ARRAY    0018H  4
  ucCOMMVoltageC . . . . . . . . . . .  MEMBER   -----  ARRAY    001CH  4
  ucCurrent. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0020H  4
  ucCurrentA . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0024H  4
  ucCurrentB . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0028H  4
  ucCurrentC . . . . . . . . . . . . .  MEMBER   -----  ARRAY    002CH  4
  ucCOMMCurrent. . . . . . . . . . . .  MEMBER   -----  ARRAY    0030H  4
  ucCOMMCurrentA . . . . . . . . . . .  MEMBER   -----  ARRAY    0034H  4
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 62  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  ucCOMMCurrentB . . . . . . . . . . .  MEMBER   -----  ARRAY    0038H  4
  ucCOMMCurrentC . . . . . . . . . . .  MEMBER   -----  ARRAY    003CH  4
  ucPower. . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0040H  4
  ucPowerA . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0044H  4
  ucPowerB . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0048H  4
  ucPowerC . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    004CH  4
  ucCOMMPower. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0050H  4
  ucCOMMPowerA . . . . . . . . . . . .  MEMBER   -----  ARRAY    0054H  4
  ucCOMMPowerB . . . . . . . . . . . .  MEMBER   -----  ARRAY    0058H  4
  ucCOMMPowerC . . . . . . . . . . . .  MEMBER   -----  ARRAY    005CH  4
  ucFactory. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0060H  4
  ucFactoryA . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0064H  4
  ucFactoryB . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0068H  4
  ucFactoryC . . . . . . . . . . . . .  MEMBER   -----  ARRAY    006CH  4
  ucCOMMFactory. . . . . . . . . . . .  MEMBER   -----  ARRAY    0070H  4
  ucCOMMFactoryA . . . . . . . . . . .  MEMBER   -----  ARRAY    0074H  4
  ucCOMMFactoryB . . . . . . . . . . .  MEMBER   -----  ARRAY    0078H  4
  ucCOMMFactoryC . . . . . . . . . . .  MEMBER   -----  ARRAY    007CH  4
  ucFrequency. . . . . . . . . . . . .  MEMBER   -----  ARRAY    0080H  4
  ucMeterConst . . . . . . . . . . . .  MEMBER   -----  ARRAY    0084H  3
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
_ApiDLT645_SafeCertification . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  j. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
  V_ucDI . . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0003H  4
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0007H  1
  V_ulDI0DI1DI2DI3 . . . . . . . . . .  AUTO     XDATA  U_LONG   0008H  4
EX4. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
FLASHCON . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A7H  1
_PrepaymentModule_Comm_INTAUTH_Invalid  EXTERN   CODE   PROC     -----  -----
LIB_E2P_Money_Para . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
TL2. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CCH  1
LIB_E2P_ENERGY_DECPULSE_BK . . . . . .  E_CONST  -----  U_CHAR   -----  1
LIB_E2P_AvailTimer . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
ADCDH. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C5H  1
LIB_E2P_Price. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_AVAIL_Type. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  41
  us_IDAvailTimer. . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  ucBackMonFlag. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0003H  2
  ulAutRemainingTime . . . . . . . . .  MEMBER   -----  U_LONG   0005H  4
  ucRechangeMoney. . . . . . . . . . .  MEMBER   -----  ARRAY    0009H  4
  ucBuybeforeMoney . . . . . . . . . .  MEMBER   -----  ARRAY    000DH  4
  ucbeforeFwEnergy . . . . . . . . . .  MEMBER   -----  ARRAY    0011H  4
  ucbeforeBkEnergy . . . . . . . . . .  MEMBER   -----  ARRAY    0015H  4
  ucE2Key. . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0019H  16
GU_BoolWordVariable. . . . . . . . . .  TYPEDEF  -----  UNION    -----  2
  BYTE . . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  2
  BIT. . . . . . . . . . . . . . . . .  MEMBER   -----  STRUCT   0000H  2
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
PWMCON . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009FH  1
_BleDrv_SetBleTPL. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_PRICE . . . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  14
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 63  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
GT_ucaMaterType. . . . . . . . . . . .  PUBLIC   CODE   ARRAY    0008H  10
GA_ucOperCode. . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  4
char8. . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
_ApiDLT645_WriteEmuReg . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
GA_ucRelayOperCode . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  4
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
ADCDL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C4H  1
ADT. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C2H  1
LIB_E2P_INDEX. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
ApiDLT645_GetStatusFlag3 . . . . . . .  STATIC   CODE   PROC     0000H  -----
  V_usResult . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
_ApiDLT645_WriteMeterAddress . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
_LibPub_CheckPassword. . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_PRICE_Type. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  14
  ucaPrice . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
  ucaPurchaseMoneyAll. . . . . . . . .  MEMBER   -----  ARRAY    0004H  4
  ucPurchaseTimes. . . . . . . . . . .  MEMBER   -----  ARRAY    0008H  4
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
DPH. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0083H  1
_BleDrv_GetBleName . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_PrepaymentModule_Comm_OpenAccout. . .  EXTERN   CODE   PROC     -----  -----
GStr_VirtualEsamPara . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  64
GStr_Flag. . . . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  16
DPL. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0082H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
_PrepaymentModule_Comm_HandBackMoney .  EXTERN   CODE   PROC     -----  -----
COMM_BLE_EADV. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LIB_E2P_FUN_CONFIG . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EXEN2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
SBUF2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F9H  1
_ApiDLT645_ReadData07. . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  P_ucTemp . . . . . . . . . . . . . .  * REG *  DATA   PTR      0001H  3
  V_ucErrorType. . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  V_ucTable. . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0001H  5
  V_ulDI3DI2DI1DI0 . . . . . . . . . .  AUTO     XDATA  U_LONG   0006H  4
  V_Temp . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000AH  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000BH  1
  V_Temp1. . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000CH  1
  V_LcdNum . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   000DH  1
  V_ucPassword . . . . . . . . . . . .  AUTO     XDATA  ARRAY    000EH  11
  V_ucTempData . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0019H  60
  V_usStateFlag3 . . . . . . . . . . .  AUTO     XDATA  U_INT    0055H  2
_ReadEventRecordData . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EMU_COMM_CAL_TAB_Type. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  ucCommDI1. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ucEmuAddr. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
LIB_E2P_ENERGY_DECPULSE_FW . . . . . .  E_CONST  -----  U_CHAR   -----  1
SM11_RXOV1 . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DEH  1
PADCL. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
REN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 64  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
_LibPub_0xFFCheckInt . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
STATUS . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
LCDCON1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D1H  1
ADCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C1H  1
SCON2. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
TCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008FH  1
LIB_E2P_EventValidPiont. . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LIB_E2P_ENRGY. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_LibPub_1Hex_2_1BCD. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LCDCON2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
EDTAH. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
T2MOD. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C9H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
_ApiDLT645_RelayControl. . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucTemp . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0002H  1
EMU_UIPKms_Type. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  14
  ulaKmsuip. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  12
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
GStr_EventValidPiont . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  8
_LibPub_CompareData. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_LibPub_CalSum . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_FUN_CONFIG_Type . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  16
  ucFunCurrentVal. . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  ucFunMeterConst. . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  ucRes. . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0002H  12
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000EH  2
GStr_EventParaData . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  V_usEventID. . . . . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  V_usEventAddr. . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  V_ucEventLenth . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
LIB_E2P_Money. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_LibPub_MemCopyBytes . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EDTAL. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
_ApiDLT645_MeterClear. . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
_BleDrv_GetBleMac. . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_EEPROM_MAP. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  ucE2pAddressIndex. . . . . . . . . .  MEMBER   -----  U_INT    0000H  2
  usE2pAddress . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  ucE2pSize. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  ucE2pLen . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  ucIsCRC. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  ucIsBak. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
EDTAM. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0093H  1
TK0DIFH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
SADEN. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009BH  1
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
ApiPwOn_MeterClear . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LIB_E2P_METER_INFO . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_LibPub_ReadDataFromE2prom . . . . . .  EXTERN   CODE   PROC     -----  -----
GStr_Money . . . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  14
TK1DIFH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
PBANK. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B6H  1
GStr_FunConfigPara . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  16
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 65  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


GStr_EventValidPiont_Type. . . . . . .  TYPEDEF  -----  STRUCT   -----  8
  uc_Point . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  6
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0006H  2
TK2DIFH. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
_BleDrv_CommGetBlePara . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EADTP. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
SADDR. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009AH  1
TK0DIFL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CFH  1
_DrvE2p_ReadData . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
LIB_E2P_ENERGY_DECPULSE_WS . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_MONEY_Type. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  14
  ucaRemainMoney . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  6
  ucaTickMoney . . . . . . . . . . . .  MEMBER   -----  ARRAY    0006H  6
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
TK1DIFL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BDH  1
_MultiDataWrite_Deal . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  v_ucChID . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0000H  1
  V_ucErrorType. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0001H  1
  P_ucTemp . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0002H  35
  V_ucTempData . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0025H  70
  V_DATALen. . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   006BH  1
  V_DATALen1 . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   006CH  1
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   006DH  1
  j. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   006EH  1
  NN . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   006FH  1
  V_ucMoneyflag. . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0070H  1
  V_ucDATANum. . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0071H  1
  V_ulDI3DI2DI1DI0 . . . . . . . . . .  AUTO     XDATA  ARRAY    0072H  40
  V_ucDATAOffset . . . . . . . . . . .  AUTO     XDATA  ARRAY    009AH  11
  V_ucDATALen. . . . . . . . . . . . .  AUTO     XDATA  ARRAY    00A5H  10
  V_usStateFlag3 . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  AlarmMoneyL1_Set . . . . . . . . . .  AUTO     XDATA  U_CHAR   00AFH  1
  AlarmMoneyL2_Set . . . . . . . . . .  AUTO     XDATA  U_CHAR   00B0H  1
TK2DIFL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BFH  1
_ApiEvent_WriteRecord. . . . . . . . .  EXTERN   CODE   PROC     -----  -----
P7816L . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
LPDCON1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C6H  1
LIB_E2P_EMU_UIPKms_BAK . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_MoneyPara . . . . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  25
LPDCON2. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C7H  1
MAX_BLE_INDEX. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
LIB_E2P_SecretKey. . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
IRDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00AEH  1
_LibPub_MemExchangeBytes . . . . . . .  EXTERN   CODE   PROC     -----  -----
F1 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
EMUIE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0096H  1
SFINE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   009EH  1
XPAGE. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F7H  1
Gstr_VirtualEsam . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  64
  ucTempKey. . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  16
  ucDisKey . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0010H  16
  ucComplexKey . . . . . . . . . . . .  MEMBER   -----  ARRAY    0020H  16
  ucRs485RandNum . . . . . . . . . . .  MEMBER   -----  ARRAY    0030H  8
  ucRs485RandNum2. . . . . . . . . . .  MEMBER   -----  ARRAY    0038H  8
GStr_MONEY_PARA_Type . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  25
  ucaAlarmMoneyL1. . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  4
C51 COMPILER V9.54   APPDLT645                                                             11/18/2021 18:53:10 PAGE 66  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  ucaAlarmMoneyL2. . . . . . . . . . .  MEMBER   -----  ARRAY    0004H  4
  ucaMaxMoneyLimit . . . . . . . . . .  MEMBER   -----  ARRAY    0008H  4
  ucaTickMoneyLimit. . . . . . . . . .  MEMBER   -----  ARRAY    000CH  4
  ucaAllowcloseMoney . . . . . . . . .  MEMBER   -----  ARRAY    0010H  4
  ucaOverLoadVal . . . . . . . . . . .  MEMBER   -----  ARRAY    0014H  3
  usCRC16. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0017H  2
INT8S. . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
EMUIF. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0097H  1
API_COMM_STATUS_FRAME_OK . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_PrepaymentModule_CommWriteESAMBinaryMACEXTERN   CODE   PROC     -----  -----
INT8U. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
_BleDrv_CommSetBlePara . . . . . . . .  EXTERN   CODE   PROC     -----  -----
_LibPub_MemSetBytes. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
FP32 . . . . . . . . . . . . . . . . .  TYPEDEF  -----  FLOAT    -----  4
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
_PrepaymentModule_Comm_ModifyKey . . .  EXTERN   CODE   PROC     -----  -----
API_COMM_STATUS_FRAME. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
GStr_EventRecordNum. . . . . . . . . .  EXTERN   XDATA  STRUCT   -----  26
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DAH  1
SPDAT. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A3H  1
IB_CON1. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  22873    ----
   CONSTANT SIZE    =    773    ----
   XDATA SIZE       =      2     464
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
