方法一：从后往前
用min记录能到达终点的最小的位置——比如说某个点，能够经过一系列跳跃到达终点，那min就记录这个点的索引，然后往前检查，如果前面的点的跳跃距离能跳过min，那这个点就一定能跳到min（前面的点不一定是与索引min挨着的点，也可能是再往前的点，所以，中途遇到不行的点也不能停下，必须检索到开始的位置）

最后的地方可以检索到索引为1，然后判断索引0能不能跳到min之后；也可以检索到索引0，判断min是不是0即可

方法二：从前往后
用max记录前面的点能跳到的最大的位置——比如说某个点，从起点经过一系列跳跃之后能到达这个点，那么在这个点能跳到的最大位置就是这个点的索引加上这个点的值，然后前面的点能跳到的最大位置可能就已经超过这个点能跳到的最大位置了（这个位置保存在max中），所以，每次max更新要比较当前最大位置跟已有max值，取较大值

如果某个点的索引值超过了max，那说明前面的点无论怎么跳，都到不了当前位置，那后面的位置就更到不了了，肯定也到不了终点，直接返回false就好

如果循环结束了，也没有找到到不了的点，那就返回true

作者：hamiguaex163com
链接：https://leetcode-cn.com/problems/jump-game/solution/cong-qian-cong-hou-du-xing-a-by-hamiguaex163com/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。